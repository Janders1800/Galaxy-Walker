<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Galaxy Walker Demo</title>
        <style>
            html,
            body {
                margin: 0;
                height: 100%;
                overflow: hidden;
                background: #000;
            }
            #hud {
                position: fixed;
                left: 12px;
                top: 12px;
                z-index: 10;
                color: #fff;
                font:
                    13px/1.35 system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    sans-serif;
                background: rgba(0, 0, 0, 0.45);
                padding: 10px 12px;
                border-radius: 10px;
                backdrop-filter: blur(6px);
                max-width: 980px;
                pointer-events: none;
            }
            #msg {
                opacity: 0.9;
                margin-top: 6px;
                white-space: pre;
            }
            #crosshair {
                position: fixed;
                left: 50%;
                top: 50%;
                width: 8px;
                height: 8px;
                transform: translate(-50%, -50%);
                border-radius: 999px;
                border: 2px solid rgba(255, 255, 255, 0.75);
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.25);
                opacity: 0;
                pointer-events: none;
                z-index: 11;
            }
            #crosshair.on {
                opacity: 0.9;
            }
            #galaxyMap {
                position: fixed;
                right: 12px;
                bottom: 12px;
                width: 340px;
                height: 340px;
                z-index: 12;
                border-radius: 14px;
                background: rgba(0, 0, 0, 0.35);
                border: 1px solid rgba(255, 255, 255, 0.14);
                backdrop-filter: blur(6px);
                pointer-events: none; /* keep mouse look */
                opacity: 0.95;
            }
            #galaxyMap.off {
                display: none;
            }
            #galaxyMap.warpHide {
                display: none !important;
            }
            #fps {
                position: fixed;
                right: 12px;
                top: 12px;
                z-index: 20;
                color: #fff;
                font:
                    12px/1.2 ui-monospace,
                    SFMono-Regular,
                    Menlo,
                    Monaco,
                    Consolas,
                    "Liberation Mono",
                    "Courier New",
                    monospace;
                background: rgba(0, 0, 0, 0.45);
                padding: 8px 10px;
                border-radius: 10px;
                backdrop-filter: blur(6px);
                pointer-events: none;
                user-select: none;
                letter-spacing: 0.3px;
            }

            #qualityUI {
                position: fixed;
                right: 12px;
                top: 48px;
                z-index: 21;
                color: #fff;
                font:
                    12px/1.2 ui-monospace,
                    SFMono-Regular,
                    Menlo,
                    Monaco,
                    Consolas,
                    "Liberation Mono",
                    "Courier New",
                    monospace;
                background: rgba(0, 0, 0, 0.45);
                padding: 8px 10px;
                border-radius: 10px;
                backdrop-filter: blur(6px);
                pointer-events: auto;
                user-select: none;
                letter-spacing: 0.3px;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            #qualityUI label {
                opacity: 0.9;
            }
            #qualityUI select {
                pointer-events: auto;
                /*background: rgba(255, 255, 255, 0.08);*/
                /*color: #fff;*/
                border: 1px solid rgba(255, 255, 255, 0.18);
                border-radius: 8px;
                padding: 4px 8px;
                outline: none;
            }

            #galaxyOverlay {
                position: fixed;
                inset: 0;
                z-index: 1000;
                background: rgba(0, 0, 0, 0.92);
                backdrop-filter: blur(6px);
                display: grid;
                place-items: stretch;
                pointer-events: auto;
            }

            #galaxyOverlay.off {
                display: none;
            }

            #galaxyFull {
                width: 100%;
                height: 100%;
                display: block;
            }

            #galaxyOverlayHud {
                position: fixed;
                left: 12px;
                top: 12px;
                z-index: 1001;
                color: #fff;
                font:
                    13px/1.35 system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    sans-serif;
                background: rgba(0, 0, 0, 0.45);
                padding: 10px 12px;
                border-radius: 10px;
                max-width: 980px;
                pointer-events: none;
            }

            #chargeUI {
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                z-index: 1002;
                color: #fff;
                font:
                    12px/1.15 ui-monospace,
                    SFMono-Regular,
                    Menlo,
                    Monaco,
                    Consolas,
                    "Liberation Mono",
                    "Courier New",
                    monospace;
                background: rgba(0, 0, 0, 0.55);
                padding: 14px 16px;
                border: 1px solid rgba(255, 255, 255, 0.18);
                border-radius: 12px;
                backdrop-filter: blur(6px);
                white-space: pre;
                text-align: center;
                display: none;
                pointer-events: none;
                user-select: none;
                letter-spacing: 0.3px;
                min-width: 220px;
            }
            #chargeUI.on {
                display: block;
            }
        </style>
    </head>
    <body>
        <div id="hud">
            <div>
                <b>Galaxy Walker Demo</b> — quadtree patches + skirts, distance
                culling, nearest-K LOD, sea-level oceans + biomes,
                <b>ocean waves</b>, <b>murky underwater (POST)</b>,
                <b>per-planet log-depth atmospheres + clouds</b>,
                <b>galaxy sky dome</b>, <b>god rays (cloud-occluded)</b>,
                <b>moons (no atmo)</b>, <b>Sun Shadows:</b> Custom PointLight +
                SpotLight; SpotLight tracks player (hi-res), the PointLight
                (low-res. No render-layer passes.
            </div>
            <div>
                <br />Click lock • Mouse look • WASD move • Shift boost • Space
                up/jump • Ctrl down • <b>F</b> take off • <b>L</b> land nearest
                • <b>R</b> respawn • <b>Q/E</b> roll (fly) • <b>M</b> toggle map
                • +/- zoom map • <b>G</b> full galaxy map • <b>P</b> toggle sun
                lights
            </div>
            <div id="msg"></div>
        </div>
        <div id="chargeUI"></div>
        <div id="fps">FPS: --</div>
        <div id="qualityUI">
            <label for="qualitySelect">Quality</label>
            <select id="qualitySelect">
                <option value="Potato">Potato</option>
                <option value="Laptop">Laptop</option>
                <option value="Descktop" selected>Descktop</option>
                <option value="GamingPC">GamingPC</option>
                <option value="NASA">NASA</option>
            </select>
        </div>
        <div id="crosshair"></div>
        <canvas id="galaxyMap"></canvas>

        <div id="galaxyOverlay" class="off">
            <canvas id="galaxyFull"></canvas>
            <div id="galaxyOverlayHud">
                <b>GALAXY MAP</b> — Drag: pan • Wheel: zoom • Click: select •
                Double-click: warp • Enter: center on player • Esc/G: close
            </div>
        </div>

        <script type="module">
            import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

            // ============================================================================
            // SuperPointLight: PointLight + internal SpotLight for focused, high-res shadows
            // ============================================================================
            class SuperPointLight extends THREE.PointLight {
                constructor(
                    color = 0xffffff,
                    intensity = 10,
                    distance = 0,
                    decay = 2,
                    opts = {},
                ) {
                    super(color, intensity, distance, decay);

                    const {
                        // This don't really matter but whatever
                        // point shadow defaults
                        pointCastShadow = true,
                        pointShadowMapSize = 256,
                        pointShadowNear = 0.5,
                        pointShadowFar = distance > 0 ? distance : 60,
                        pointShadowBias = -0.00015,
                        pointShadowNormalBias = 0.0,

                        // spot defaults
                        spotCastShadow = true,
                        spotShadowMapSize = 2048,
                        spotShadowNear = 0.5,
                        spotShadowFar = distance > 0 ? distance : 60,
                        spotShadowBias = -0.00008,
                        spotShadowNormalBias = 0.0,
                        spotFocus = 0.55,
                        spotAngleDeg = 16,
                        spotPenumbra = 0.35,
                        spotIntensityFactor = 0.25,
                        spotDirection = new THREE.Vector3(1, -0.55, 0.2),
                    } = opts;

                    // PointLight shadows (usually low-res)
                    this.castShadow = !!pointCastShadow;
                    if (this.castShadow) {
                        this.shadow.mapSize.set(
                            pointShadowMapSize,
                            pointShadowMapSize,
                        );
                        this.shadow.camera.near = pointShadowNear;
                        this.shadow.camera.far = pointShadowFar;
                        this.shadow.bias = pointShadowBias;
                        this.shadow.normalBias = pointShadowNormalBias;
                    }

                    // Internal spotlight for focused shadows
                    this.shadowLight = new THREE.SpotLight(
                        color,
                        intensity * spotIntensityFactor,
                        distance,
                        THREE.MathUtils.degToRad(spotAngleDeg),
                        spotPenumbra,
                        decay,
                    );
                    this.shadowLight.castShadow = !!spotCastShadow;

                    if (this.shadowLight.castShadow) {
                        this.shadowLight.shadow.mapSize.set(
                            spotShadowMapSize,
                            spotShadowMapSize,
                        );
                        this.shadowLight.shadow.camera.near = spotShadowNear;
                        this.shadowLight.shadow.camera.far = spotShadowFar;
                        this.shadowLight.shadow.bias = spotShadowBias;
                        this.shadowLight.shadow.normalBias =
                            spotShadowNormalBias;
                        this.shadowLight.shadow.focus = spotFocus;
                    }

                    this.add(this.shadowLight);
                    this.add(this.shadowLight.target);

                    this._spotIntensityFactor = spotIntensityFactor;
                    this.setSpotDirection(spotDirection);
                }

                setSpotDirection(dir) {
                    const d = dir.clone();
                    if (d.lengthSq() === 0) d.set(0, -1, 0);
                    d.normalize();
                    this.shadowLight.target.position.copy(d);
                    this.shadowLight.target.updateMatrixWorld(true);
                }

                setSpotIntensityFactor(f) {
                    this._spotIntensityFactor = f;
                    this.syncSpotIntensity();
                }

                syncSpotIntensity() {
                    this.shadowLight.color.copy(this.color);
                    this.shadowLight.distance = this.distance;
                    this.shadowLight.decay = this.decay;
                    this.shadowLight.intensity =
                        this.intensity * this._spotIntensityFactor;
                }
            }

            // ------------------------------------------------------------------------------------------
            // Material patch: kill PointLight contribution inside the SuperPointLight spotlight cone
            // (WORLD space mask => stable when camera moves)
            // ------------------------------------------------------------------------------------------

            const _spl_wp = new THREE.Vector3();
            const _spl_wt = new THREE.Vector3();
            const _spl_wdir = new THREE.Vector3();

            function attachSuperPointLightMask(material, superPointLight) {
                if (!material || material.userData?._splMasked) return;

                const prev = material.onBeforeCompile;
                material.onBeforeCompile = (shader) => {
                    if (prev) prev(shader);

                    shader.uniforms.uSPL_spotPosW = {
                        value: new THREE.Vector3(),
                    };
                    shader.uniforms.uSPL_spotDirW = {
                        value: new THREE.Vector3(0, -1, 0),
                    };
                    shader.uniforms.uSPL_cosOuter = { value: 0.0 };
                    shader.uniforms.uSPL_cosInner = { value: 0.0 };

                    shader.vertexShader = shader.vertexShader
                        .replace(
                            "#include <common>",
                            `#include <common>\nvarying vec3 vSPL_worldPos;`,
                        )
                        .replace(
                            "#include <worldpos_vertex>",
                            `#include <worldpos_vertex>\nvSPL_worldPos = worldPosition.xyz;`,
                        );

                    shader.fragmentShader = shader.fragmentShader
                        .replace(
                            "#include <common>",
                            `#include <common>\nvarying vec3 vSPL_worldPos;`,
                        )
                        .replace(
                            "#include <lights_pars_begin>",
                            `
#define getPointLightInfo getPointLightInfo_original
#include <lights_pars_begin>
#undef getPointLightInfo

uniform vec3 uSPL_spotPosW;
uniform vec3 uSPL_spotDirW;
uniform float uSPL_cosOuter;
uniform float uSPL_cosInner;

float splMaskW() {
  vec3 toFragW = normalize(vSPL_worldPos - uSPL_spotPosW); // light -> fragment
  float cosAng = dot(toFragW, normalize(uSPL_spotDirW));   // light -> target axis
  return smoothstep(uSPL_cosOuter, uSPL_cosInner, cosAng);
}

void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
  getPointLightInfo_original( pointLight, geometryPosition, light );
  float m = splMaskW();
  light.color *= (1.0 - m); // inside cone => kill point light contribution
}
                    `,
                        );

                    material.userData._splShader = shader;
                };

                material.userData._splLight = superPointLight;
                material.userData._splMasked = true;
                material.needsUpdate = true;
            }

            function updateSuperPointLightMask(
                materialOrArray,
                superPointLight = null,
            ) {
                const mats = Array.isArray(materialOrArray)
                    ? materialOrArray
                    : [materialOrArray];

                for (const m of mats) {
                    const shader = m?.userData?._splShader;
                    const light = superPointLight || m?.userData?._splLight;
                    if (!shader || !light?.shadowLight) continue;

                    const spot = light.shadowLight;

                    light.updateMatrixWorld(true);
                    spot.updateMatrixWorld(true);
                    spot.target.updateMatrixWorld(true);

                    spot.getWorldPosition(_spl_wp);
                    shader.uniforms.uSPL_spotPosW.value.copy(_spl_wp);

                    spot.target.getWorldPosition(_spl_wt);
                    _spl_wdir.copy(_spl_wt).sub(_spl_wp).normalize();
                    shader.uniforms.uSPL_spotDirW.value.copy(_spl_wdir);

                    const angle = spot.angle;
                    shader.uniforms.uSPL_cosOuter.value = Math.cos(angle);
                    shader.uniforms.uSPL_cosInner.value = Math.cos(
                        angle * (1.0 - spot.penumbra),
                    );
                }
            }

            const splMaskedMaterials = [];
            function _isLitMaterial(mat) {
                return !!(
                    mat &&
                    (mat.isMeshStandardMaterial ||
                        mat.isMeshPhysicalMaterial ||
                        mat.isMeshPhongMaterial ||
                        mat.isMeshLambertMaterial ||
                        mat.isMeshToonMaterial)
                );
            }
            function registerSPLMaterial(mat, light) {
                if (!_isLitMaterial(mat)) return;
                if (mat.userData?._splMasked) return;
                attachSuperPointLightMask(mat, light);
                splMaskedMaterials.push(mat);
            }
            function registerSPLMaterialsIn(root, light) {
                if (!root) return;
                root.traverse((obj) => {
                    if (!obj || !obj.isMesh) return;
                    // skip the sun mesh if present
                    if (
                        typeof sun !== "undefined" &&
                        (obj === sun || obj.parent === sun)
                    )
                        return;

                    const m = obj.material;
                    if (Array.isArray(m))
                        m.forEach((mm) => registerSPLMaterial(mm, light));
                    else registerSPLMaterial(m, light);
                });
            }
            function clearSPLMaterialRegistry() {
                splMaskedMaterials.length = 0;
            }

            // ============================================================================
            // Warp overlay (fullscreen post effect) — V-Drop tunnel style
            // https://www.shadertoy.com/view/wsKXRK
            // ============================================================================
            function createWarpOverlay(THREE, width, height) {
                const warpScene = new THREE.Scene();
                const warpCam = new THREE.OrthographicCamera(
                    -1,
                    1,
                    1,
                    -1,
                    0,
                    1,
                );

                const warpMat = new THREE.ShaderMaterial({
                    transparent: true,
                    depthWrite: false,
                    depthTest: false,
                    uniforms: {
                        uTime: { value: 0 },
                        uStrength: { value: 0 },
                        uFade: { value: 0 },
                        uResolution: {
                            value: new THREE.Vector2(width, height),
                        },
                        uVerticalMode: { value: 0.0 },
                    },
                    vertexShader: `
varying vec2 vUv;
void main(){
  vUv = uv;
  gl_Position = vec4(position.xy, 0.0, 1.0);
}
`,
                    fragmentShader: `
precision highp float;
varying vec2 vUv;

uniform float uTime;
uniform float uStrength;
uniform float uFade;
uniform vec2  uResolution;
uniform float uVerticalMode;

#define PI 3.141592653589793

float vDrop(vec2 uv,float t)
{
  uv.x = uv.x*128.0;
  float dx = fract(uv.x);
  uv.x = floor(uv.x);
  uv.y *= 0.05;
  float o=sin(uv.x*215.4);
  float s=cos(uv.x*33.1)*.3 +.7;
  float trail = mix(95.0,35.0,s);
  float yv = fract(uv.y + t*s + o) * trail;
  yv = 1.0/max(yv, 1e-4);
  yv = smoothstep(0.0,1.0,yv*yv);
  yv = sin(yv*PI)*(s*5.0);
  float d2 = sin(dx*PI);
  return yv*(d2*d2);
}

void main(){
  float s = clamp(uStrength, 0.0, 1.0);
  float a = clamp(uFade, 0.0, 1.0);
  if (a <= 0.0001) { gl_FragColor = vec4(0.0); return; }

  vec2 fragCoord = vUv * uResolution;
  vec2 p = (fragCoord.xy - 0.5 * uResolution.xy) / max(uResolution.y, 1.0);

  float d = length(p)+0.1;
  p = vec2(atan(p.x, p.y) / PI, 2.5 / max(d, 1e-4));
  if (uVerticalMode > 0.5) p.y *= 0.5;

  float t =  uTime*0.4;

  vec3 col = vec3(1.55,0.65,.225) * vDrop(p,t);
  col += vec3(0.55,0.75,1.225) * vDrop(p,t+0.33);
  col += vec3(0.45,1.15,0.425) * vDrop(p,t+0.66);

  col *= (d*d);
  col *= s;

  gl_FragColor = vec4(col, a);
}
`,
                });

                const warpQuad = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2),
                    warpMat,
                );
                warpQuad.frustumCulled = false;
                warpScene.add(warpQuad);

                return { warpScene, warpCam, warpMat };
            }

            function resizeWarpOverlay(warpMat, w, h) {
                warpMat.uniforms.uResolution.value.set(w, h);
            }

            function makeChargeUI(chargeUIEl) {
                const el = chargeUIEl;

                function setCharging(progress01) {
                    const width = 18;
                    const half = width / 2;

                    const pairsFilled = Math.round(
                        Math.max(0, Math.min(1, progress01)) * half,
                    );
                    const left =
                        " ".repeat(half - pairsFilled) +
                        "|".repeat(pairsFilled);
                    const right =
                        "|".repeat(pairsFilled) +
                        " ".repeat(half - pairsFilled);

                    el.textContent = `[CHARGING]\n[${left}${right}]`;
                    el.classList.add("on");
                }

                function setCountdown(secondsLeft) {
                    const s = Math.max(0, secondsLeft);
                    const whole = Math.floor(s);
                    const hund = Math.floor((s - whole) * 100);

                    const ss = whole.toString().padStart(2, "0");
                    const hh = hund.toString().padStart(2, "0");

                    const width = 18;
                    const inside = "|".repeat(width);

                    el.textContent = `[${ss}.${hh}]\n[${inside}]`;
                    el.classList.add("on");
                }

                function hide() {
                    el.classList.remove("on");
                }

                return { setCharging, setCountdown, hide };
            }

            // ============================================================================
            // Warp CHARGE sound + countdown beeps
            // ============================================================================
            function makeChargeSound() {
                let audioCtx = null;
                let chargeSnd = null;

                function ensureAudio() {
                    if (audioCtx) return;
                    audioCtx = new (
                        window.AudioContext || window.webkitAudioContext
                    )();

                    function makeImpulse(seconds = 1.2, decay = 3.0) {
                        const rate = audioCtx.sampleRate;
                        const len = Math.floor(rate * seconds);
                        const buf = audioCtx.createBuffer(2, len, rate);
                        for (let ch = 0; ch < 2; ch++) {
                            const d = buf.getChannelData(ch);
                            for (let i = 0; i < len; i++) {
                                const t = i / len;
                                d[i] =
                                    (Math.random() * 2 - 1) *
                                    Math.pow(1 - t, decay);
                            }
                        }
                        return buf;
                    }

                    const convolver = audioCtx.createConvolver();
                    convolver.buffer = makeImpulse();

                    const wet = audioCtx.createGain();
                    wet.gain.value = 0.0;
                    const dry = audioCtx.createGain();
                    dry.gain.value = 1.0;

                    const master = audioCtx.createGain();
                    master.gain.value = 0.9;

                    dry.connect(master);
                    convolver.connect(wet);
                    wet.connect(master);
                    master.connect(audioCtx.destination);

                    chargeSnd = {
                        convolver,
                        wet,
                        dry,
                        master,
                        osc: null,
                        sub: null,
                        noise: null,
                        noiseGain: null,
                        subGain: null,
                        filter: null,
                        outGain: null,
                        lfo: null,
                        lfoGain: null,
                        active: false,
                    };
                }

                function resume() {
                    ensureAudio();
                    if (audioCtx && audioCtx.state !== "running")
                        return audioCtx.resume().catch(() => {});
                }

                function start() {
                    ensureAudio();
                    if (!chargeSnd || chargeSnd.active) return;

                    const now = audioCtx.currentTime;

                    const outGain = audioCtx.createGain();
                    outGain.gain.value = 0.0;
                    outGain.connect(chargeSnd.dry);
                    outGain.connect(chargeSnd.convolver);

                    const filter = audioCtx.createBiquadFilter();
                    filter.type = "lowpass";
                    filter.frequency.value = 160;
                    filter.Q.value = 0.35;
                    filter.connect(outGain);

                    const osc = audioCtx.createOscillator();
                    osc.type = "triangle";
                    osc.frequency.value = 55;

                    const oscGain = audioCtx.createGain();
                    oscGain.gain.value = 0.12;
                    osc.connect(oscGain);
                    oscGain.connect(filter);

                    const sub = audioCtx.createOscillator();
                    sub.type = "sine";
                    sub.frequency.value = 32;

                    const subGain = audioCtx.createGain();
                    subGain.gain.value = 0.0;
                    sub.connect(subGain);
                    subGain.connect(filter);

                    const noiseBuf = audioCtx.createBuffer(
                        1,
                        audioCtx.sampleRate * 2,
                        audioCtx.sampleRate,
                    );
                    const nd = noiseBuf.getChannelData(0);
                    for (let i = 0; i < nd.length; i++)
                        nd[i] = Math.random() * 2 - 1;

                    const noise = audioCtx.createBufferSource();
                    noise.buffer = noiseBuf;
                    noise.loop = true;

                    const noiseGain = audioCtx.createGain();
                    noiseGain.gain.value = 0.0;
                    noise.connect(noiseGain);
                    noiseGain.connect(filter);

                    const lfo = audioCtx.createOscillator();
                    lfo.type = "sine";
                    lfo.frequency.value = 2.0;

                    const lfoGain = audioCtx.createGain();
                    lfoGain.gain.value = 0.0;
                    lfo.connect(lfoGain);
                    lfoGain.connect(outGain.gain);

                    osc.start(now);
                    sub.start(now);
                    noise.start(now);
                    lfo.start(now);

                    chargeSnd.osc = osc;
                    chargeSnd.sub = sub;
                    chargeSnd.noise = noise;
                    chargeSnd.noiseGain = noiseGain;
                    chargeSnd.subGain = subGain;
                    chargeSnd.filter = filter;
                    chargeSnd.outGain = outGain;
                    chargeSnd.lfo = lfo;
                    chargeSnd.lfoGain = lfoGain;
                    chargeSnd.active = true;

                    outGain.gain.setValueAtTime(0.0, now);
                    outGain.gain.linearRampToValueAtTime(0.05, now + 0.08);

                    chargeSnd.wet.gain.setValueAtTime(0.2, now);
                }

                function update(p01) {
                    if (!chargeSnd || !chargeSnd.active) return;

                    const now = audioCtx.currentTime;
                    const k = Math.pow(Math.max(0, Math.min(1, p01)), 1.35);

                    chargeSnd.filter.frequency.setTargetAtTime(
                        160 + 1700 * k,
                        now,
                        0.06,
                    );
                    chargeSnd.osc.frequency.setTargetAtTime(
                        55 + 55 * k,
                        now,
                        0.06,
                    );

                    chargeSnd.subGain.gain.setTargetAtTime(
                        0.03 + 0.18 * k,
                        now,
                        0.08,
                    );
                    chargeSnd.noiseGain.gain.setTargetAtTime(
                        0.1 + 0.15 * k,
                        now,
                        0.08,
                    );

                    chargeSnd.outGain.gain.setTargetAtTime(
                        0.05 + 0.22 * k,
                        now,
                        0.08,
                    );

                    chargeSnd.lfoGain.gain.setTargetAtTime(
                        0.02 + 0.08 * k,
                        now,
                        0.12,
                    );
                    chargeSnd.lfo.frequency.setTargetAtTime(
                        2.0 + 2.5 * k,
                        now,
                        0.15,
                    );

                    chargeSnd.wet.gain.setTargetAtTime(
                        0.25 + 0.3 * k,
                        now,
                        0.15,
                    );
                }

                function stop() {
                    if (!chargeSnd || !chargeSnd.active) return;

                    const now = audioCtx.currentTime;

                    chargeSnd.outGain.gain.cancelScheduledValues(now);
                    chargeSnd.outGain.gain.setValueAtTime(
                        chargeSnd.outGain.gain.value,
                        now,
                    );
                    chargeSnd.outGain.gain.linearRampToValueAtTime(
                        0.0,
                        now + 0.1,
                    );

                    try {
                        chargeSnd.osc.stop(now + 0.12);
                    } catch {}
                    try {
                        chargeSnd.sub.stop(now + 0.12);
                    } catch {}
                    try {
                        chargeSnd.noise.stop(now + 0.12);
                    } catch {}
                    try {
                        chargeSnd.lfo.stop(now + 0.12);
                    } catch {}

                    setTimeout(() => {
                        chargeSnd.osc = null;
                        chargeSnd.sub = null;
                        chargeSnd.noise = null;
                        chargeSnd.active = false;
                    }, 200);
                }

                // Short "UI beep" helpers for countdown ticks
                function _beep({
                    freq = 880,
                    dur = 0.08,
                    vol = 0.22,
                    type = "sine",
                } = {}) {
                    ensureAudio();
                    const now = audioCtx.currentTime;

                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    const hp = audioCtx.createBiquadFilter();

                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, now);

                    hp.type = "highpass";
                    hp.frequency.value = 260;

                    // Fast envelope
                    g.gain.setValueAtTime(0.0001, now);
                    g.gain.exponentialRampToValueAtTime(vol, now + 0.008);
                    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

                    osc.connect(hp);
                    hp.connect(g);
                    g.connect(
                        chargeSnd ? chargeSnd.master : audioCtx.destination,
                    );

                    osc.start(now);
                    osc.stop(now + dur + 0.02);
                }

                // Before beepTick changed over time but
                // too lazy to change the function calls
                function beepTick() {
                    // Countdown beep — fixed parameters per request
                    _beep({ freq: 300, dur: 0.6, vol: 5.0, type: "sine" });
                }

                function beepFinal() {
                    // Final beep — same parameters as countdown beeps
                    _beep({ freq: 300, dur: 0.6, vol: 5.0, type: "sine" });
                }

                return {
                    ensureAudio,
                    resume,
                    start,
                    update,
                    stop,
                    beepTick,
                    beepFinal,
                };
            }

            function renderWarpOverlay(renderer, warpOverlay, shouldDraw) {
                if (!shouldDraw) return;
                const oldAuto = renderer.autoClear;
                renderer.autoClear = false;
                renderer.clearDepth();
                renderer.render(warpOverlay.warpScene, warpOverlay.warpCam);
                renderer.autoClear = oldAuto;
            }

            function makeWarpController({
                THREE,
                warpMat,
                chargeUI,
                chargeSound,
                canWarp = () => true,
                getWarpDirection = () => new THREE.Vector3(0, 0, -1),
                onWarpStart,
                onWarpRebuildSystem,
                onWarpArrive,

                addVelocityForward, // (dirW, accel, dt) => void
                dampVelocity, // (damp, dt) => void  (frame-rate independent via pow)
                integratePosition, // (dt) => void
                interpolateLookAt, // (p01, dirW, dt) => void
            }) {
                const warp = {
                    active: false,
                    phase: "idle", // idle | charge | countdown | travel | out | reveal
                    target: null,

                    chargeT: 0,
                    countdownT: 0,
                    travelT: 0,
                    outT: 0,
                    revealT: 0,

                    // Timings
                    chargeDur: 15.0,
                    countdownDur: 5.99,
                    travelDur: 15.0,
                    outDur: 1.2,
                    revealDur: 0.25,

                    dirW: new THREE.Vector3(0, 0, -1),
                    didRebuild: false,
                    _lastBeepSec: 6,
                };

                function start(target) {
                    if (warp.active) return false;
                    if (!canWarp()) return false;

                    warp.active = true;
                    warp.target = target;
                    warp.phase = "charge";
                    warp.chargeT = 0;
                    warp.countdownT = 0;
                    warp.travelT = 0;
                    warp.outT = 0;
                    warp.revealT = 0;
                    warp.didRebuild = false;

                    warp.dirW.copy(getWarpDirection(target)).normalize();

                    warpMat.uniforms.uStrength.value = 0.0;
                    warpMat.uniforms.uFade.value = 0.0;

                    onWarpStart?.(target);
                    chargeUI.setCharging(0);
                    if (chargeSound) {
                        chargeSound.ensureAudio?.();
                        chargeSound.resume?.();
                        chargeSound.start?.();
                    }
                    warp._lastBeepSec = 6;
                    return true;
                }

                function update(dt, timeSeconds) {
                    warpMat.uniforms.uTime.value = timeSeconds;
                    if (!warp.active) return;

                    if (warp.phase === "charge") {
                        warp.chargeT += dt;
                        const p01 = THREE.MathUtils.clamp(
                            warp.chargeT / warp.chargeDur,
                            0,
                            1,
                        );
                        chargeUI.setCharging(p01);
                        if (chargeSound) chargeSound.update?.(p01);

                        warpMat.uniforms.uStrength.value = 0.0;
                        warpMat.uniforms.uFade.value = 0.0;

                        // Acceleration ramp up hard near the end
                        if (addVelocityForward)
                            addVelocityForward(
                                warp.dirW,
                                THREE.MathUtils.lerp(250.0, 5200.0, p01 * p01),
                                dt,
                            );
                        if (dampVelocity) dampVelocity(0.992, dt);

                        // Interpolated look-at while charging
                        if (interpolateLookAt)
                            interpolateLookAt(p01, warp.dirW, dt);

                        if (integratePosition) integratePosition(dt);

                        if (p01 >= 1.0) {
                            warp.phase = "countdown";
                            warp.countdownT = 0;
                            warp._lastBeepSec = 6;
                            chargeSound?.beepFinal?.();
                        }
                    } else if (warp.phase === "countdown") {
                        warp.countdownT += dt;

                        if (chargeSound) chargeSound.update?.(1.0);
                        const timeLeft = warp.countdownDur - warp.countdownT;
                        chargeUI.setCountdown(timeLeft);

                        // Countdown beeps
                        const sec = Math.ceil(timeLeft);
                        if (sec !== warp._lastBeepSec) {
                            warp._lastBeepSec = sec;
                            if (sec <= 5 && sec >= 1) {
                                const urgency = (6 - sec) / 5; // 0..1
                                chargeSound?.beepTick?.(urgency);
                            }
                        }
                        warpMat.uniforms.uStrength.value = 0.0;
                        warpMat.uniforms.uFade.value = 0.0;

                        // Keep the camera eased toward the warp vector
                        if (interpolateLookAt)
                            interpolateLookAt(1.0, warp.dirW, dt);
                        if (dampVelocity) dampVelocity(0.992, dt);
                        if (integratePosition) integratePosition(dt);

                        if (warp.countdownT >= warp.countdownDur) {
                            //chargeSound?.beepFinal?.();
                            chargeSound?.stop?.();

                            warp.phase = "travel";
                            warp.travelT = 0;
                            chargeUI.hide();
                            warpMat.uniforms.uStrength.value = 0.0;
                            warpMat.uniforms.uFade.value = 0.0;

                            // Hide minimap during warp
                            document
                                .getElementById("galaxyMap")
                                ?.classList.add("warpHide");
                        }
                    } else if (warp.phase === "travel") {
                        warp.travelT += dt;

                        // Ramp the overlay in quickly
                        const ramp = THREE.MathUtils.clamp(
                            warp.travelT / 0.35,
                            0,
                            1,
                        );
                        warpMat.uniforms.uStrength.value = ramp;
                        warpMat.uniforms.uFade.value = 1.0;

                        if (addVelocityForward)
                            addVelocityForward(warp.dirW, 45.0, dt);
                        if (dampVelocity) dampVelocity(0.996, dt);
                        if (interpolateLookAt)
                            interpolateLookAt(1.0, warp.dirW, dt);
                        if (integratePosition) integratePosition(dt);

                        // Rebuild while tunnel is fully active (after ramp reaches 1)
                        if (!warp.didRebuild && ramp >= 1.0) {
                            onWarpRebuildSystem?.(warp.target);
                            warp.didRebuild = true;
                        }

                        if (warp.travelT >= warp.travelDur) {
                            onWarpArrive?.(warp.target);
                            warp.phase = "out";
                            warp.outT = 0;
                            warpMat.uniforms.uStrength.value = 1.0;
                            warpMat.uniforms.uFade.value = 1.0;
                        }
                    } else if (warp.phase === "out") {
                        warp.outT += dt;
                        const k = THREE.MathUtils.clamp(
                            warp.outT / warp.outDur,
                            0,
                            1,
                        );
                        const s = 1.0 - THREE.MathUtils.smoothstep(k, 0.0, 1.0);

                        warpMat.uniforms.uStrength.value = s;
                        warpMat.uniforms.uFade.value = 1.0;

                        if (integratePosition) integratePosition(dt);

                        if (k >= 1.0) {
                            // Hold black for a beat, then fade back in cleanly to avoid camera-angle pops
                            warp.phase = "reveal";
                            warp.revealT = 0;
                            warpMat.uniforms.uStrength.value = 0.0;
                            warpMat.uniforms.uFade.value = 1.0;
                        }
                    } else if (warp.phase === "reveal") {
                        warp.revealT += dt;
                        const k = THREE.MathUtils.clamp(
                            warp.revealT / warp.revealDur,
                            0,
                            1,
                        );
                        const a = 1.0 - THREE.MathUtils.smoothstep(k, 0.0, 1.0);

                        // Fade from black back to the scene with no tunnel visible
                        warpMat.uniforms.uStrength.value = 0.0;
                        warpMat.uniforms.uFade.value = a;

                        if (k >= 1.0) {
                            warp.active = false;
                            warp.phase = "idle";
                            // Restore minimap after warp
                            document
                                .getElementById("galaxyMap")
                                ?.classList.remove("warpHide");
                            warp.target = null;
                            warpMat.uniforms.uStrength.value = 0.0;
                            warpMat.uniforms.uFade.value = 0.0;
                        }
                    }
                }

                function isOverlayVisible() {
                    return (
                        warp.active &&
                        (warp.phase === "travel" ||
                            warp.phase === "out" ||
                            warp.phase === "reveal")
                    );
                }

                function isMovementLocked() {
                    return warp.active;
                }

                return {
                    warp,
                    start,
                    update,
                    isOverlayVisible,
                    isMovementLocked,
                };
            }

            ////////////////////////////////////////////////////////////////////////////////
            // Seeded noise + FBM
            ////////////////////////////////////////////////////////////////////////////////
            function hash3s(x, y, z, seed) {
                let h = (x | 0) ^ seed;
                h = Math.imul(h ^ (y | 0), 0x9e3779b1);
                h = Math.imul(h ^ (z | 0), 0x85ebca77);
                h ^= h >>> 16;
                return (h >>> 0) / 4294967295;
            }
            const smoothstep = (t) => t * t * (3 - 2 * t);
            const lerp = (a, b, t) => a + (b - a) * t;

            function valueNoise3Seeded(px, py, pz, seed) {
                const x0 = Math.floor(px),
                    y0 = Math.floor(py),
                    z0 = Math.floor(pz);
                const x1 = x0 + 1,
                    y1 = y0 + 1,
                    z1 = z0 + 1;
                const tx = smoothstep(px - x0),
                    ty = smoothstep(py - y0),
                    tz = smoothstep(pz - z0);

                const c000 = hash3s(x0, y0, z0, seed),
                    c100 = hash3s(x1, y0, z0, seed);
                const c010 = hash3s(x0, y1, z0, seed),
                    c110 = hash3s(x1, y1, z0, seed);
                const c001 = hash3s(x0, y0, z1, seed),
                    c101 = hash3s(x1, y0, z1, seed);
                const c011 = hash3s(x0, y1, z1, seed),
                    c111 = hash3s(x1, y1, z1, seed);

                const x00 = lerp(c000, c100, tx),
                    x10 = lerp(c010, c110, tx);
                const x01 = lerp(c001, c101, tx),
                    x11 = lerp(c011, c111, tx);
                const y0v = lerp(x00, x10, ty),
                    y1v = lerp(x01, x11, ty);
                return lerp(y0v, y1v, tz) * 2 - 1;
            }

            function fbm3Seeded(
                px,
                py,
                pz,
                seed,
                oct = 5,
                lac = 2.0,
                gain = 0.5,
            ) {
                let amp = 0.5,
                    freq = 1.0,
                    sum = 0.0;
                for (let i = 0; i < oct; i++) {
                    sum +=
                        amp *
                        valueNoise3Seeded(
                            px * freq,
                            py * freq,
                            pz * freq,
                            seed + i * 1013,
                        );
                    freq *= lac;
                    amp *= gain;
                }
                return sum;
            }

            ////////////////////////////////////////////////////////////////////////////////
            // Cube face mapping + cubesphere correction
            ////////////////////////////////////////////////////////////////////////////////
            function faceUvToCube(face, u, v) {
                switch (face) {
                    case 0:
                        return { x: 1, y: v, z: -u }; // +X
                    case 1:
                        return { x: -1, y: v, z: u }; // -X
                    case 2:
                        return { x: u, y: 1, z: -v }; // +Y
                    case 3:
                        return { x: u, y: -1, z: v }; // -Y
                    case 4:
                        return { x: u, y: v, z: 1 }; // +Z
                    case 5:
                        return { x: -u, y: v, z: -1 }; // -Z
                    default:
                        return { x: 0, y: 1, z: 0 };
                }
            }
            function cubeToCubesphereDir(x, y, z) {
                const x2 = x * x,
                    y2 = y * y,
                    z2 = z * z;
                const sx = x * Math.sqrt(1 - y2 / 2 - z2 / 2 + (y2 * z2) / 3);
                const sy = y * Math.sqrt(1 - z2 / 2 - x2 / 2 + (z2 * x2) / 3);
                const sz = z * Math.sqrt(1 - x2 / 2 - y2 / 2 + (x2 * y2) / 3);
                const inv = 1 / Math.hypot(sx, sy, sz);
                return { x: sx * inv, y: sy * inv, z: sz * inv };
            }

            ////////////////////////////////////////////////////////////////////////////////
            // SDF + normal
            ////////////////////////////////////////////////////////////////////////////////
            function makePlanetSdf(radiusAtDir) {
                return (px, py, pz) => {
                    const r = Math.hypot(px, py, pz);
                    if (r < 1e-6) return -radiusAtDir(0, 1, 0);
                    const inv = 1 / r;
                    const dx = px * inv,
                        dy = py * inv,
                        dz = pz * inv;
                    return r - radiusAtDir(dx, dy, dz);
                };
            }
            function sdfNormal(sdf, px, py, pz, eps) {
                const dx = sdf(px + eps, py, pz) - sdf(px - eps, py, pz);
                const dy = sdf(px, py + eps, pz) - sdf(px, py - eps, pz);
                const dz = sdf(px, py, pz + eps) - sdf(px, py, pz - eps);
                let nx = dx,
                    ny = dy,
                    nz = dz;
                const len = Math.hypot(nx, ny, nz);
                if (len < 1e-8) return { x: 0, y: 1, z: 0 };
                nx /= len;
                ny /= len;
                nz /= len;
                return { x: nx, y: ny, z: nz };
            }

            ////////////////////////////////////////////////////////////////////////////////
            // Outward winding fix
            // Gotta find a better solution
            ////////////////////////////////////////////////////////////////////////////////
            function fixWindingOutward(index, pos) {
                for (let i = 0; i < index.length; i += 3) {
                    const ia = index[i],
                        ib = index[i + 1],
                        ic = index[i + 2];
                    const ax = pos[ia * 3],
                        ay = pos[ia * 3 + 1],
                        az = pos[ia * 3 + 2];
                    const bx = pos[ib * 3],
                        by = pos[ib * 3 + 1],
                        bz = pos[ib * 3 + 2];
                    const cx = pos[ic * 3],
                        cy = pos[ic * 3 + 1],
                        cz = pos[ic * 3 + 2];
                    const abx = bx - ax,
                        aby = by - ay,
                        abz = bz - az;
                    const acx = cx - ax,
                        acy = cy - ay,
                        acz = cz - az;
                    const nx = aby * acz - abz * acy;
                    const ny = abz * acx - abx * acz;
                    const nz = abx * acy - aby * acx;
                    const mx = (ax + bx + cx) / 3,
                        my = (ay + by + cy) / 3,
                        mz = (az + bz + cz) / 3;
                    if (nx * mx + ny * my + nz * mz < 0) {
                        index[i + 1] = ic;
                        index[i + 2] = ib;
                    }
                }
            }

            ////////////////////////////////////////////////////////////////////////////////
            // Patch geometry + skirts + vertex biome colors
            ////////////////////////////////////////////////////////////////////////////////
            const clamp01 = (x) => (x < 0 ? 0 : x > 1 ? 1 : x);
            const smooth01 = (t) => t * t * (3 - 2 * t);
            const smoothstep01 = (a, b, x) =>
                smooth01(clamp01((x - a) / (b - a)));
            const mix = (a, b, t) => a + (b - a) * t;

            function buildPatchGeometry({
                face,
                u0,
                v0,
                u1,
                v1,
                gridN,
                radiusAtDir,
                sdf,
                normalEps,
                skirtDepth,
                baseRadius,
                seaLevel,
                heightAmp,
                biome,
            }) {
                const N = gridN,
                    vertsPerSide = N + 1,
                    vertCount = vertsPerSide * vertsPerSide;
                const pos = new Float32Array(vertCount * 3);
                const nrm = new Float32Array(vertCount * 3);
                const col = new Float32Array(vertCount * 3);

                const C = biome;
                const deepW = C.deepWater,
                    shallowW = C.shallowWater,
                    sand = C.sand,
                    grass = C.grass,
                    rock = C.rock,
                    snow = C.snow;

                let k = 0;
                for (let j = 0; j <= N; j++) {
                    const tv = j / N;
                    const v = v0 + (v1 - v0) * tv;
                    for (let i = 0; i <= N; i++) {
                        const tu = i / N;
                        const u = u0 + (u1 - u0) * tu;

                        const c = faceUvToCube(face, u, v);
                        const d = cubeToCubesphereDir(c.x, c.y, c.z);
                        const r = radiusAtDir(d.x, d.y, d.z);

                        const px = d.x * r,
                            py = d.y * r,
                            pz = d.z * r;
                        pos[k] = px;
                        pos[k + 1] = py;
                        pos[k + 2] = pz;

                        const nn = sdfNormal(sdf, px, py, pz, normalEps);
                        nrm[k] = nn.x;
                        nrm[k + 1] = nn.y;
                        nrm[k + 2] = nn.z;

                        const height = r - baseRadius;
                        const lat = Math.abs(d.y);
                        const shoreW = C.shoreWidth;
                        const aboveSea = r - seaLevel;

                        const waterMask =
                            1.0 - smoothstep01(-shoreW, +shoreW, aboveSea);

                        const shallowT = smoothstep01(
                            -shoreW * 1.0,
                            -shoreW * 0.15,
                            aboveSea,
                        );
                        let wR = mix(deepW.r, shallowW.r, shallowT);
                        let wG = mix(deepW.g, shallowW.g, shallowT);
                        let wB = mix(deepW.b, shallowW.b, shallowT);

                        const sandT =
                            1.0 - smoothstep01(0.0, shoreW * 1.2, aboveSea);
                        let lR = mix(grass.r, sand.r, sandT);
                        let lG = mix(grass.g, sand.g, sandT);
                        let lB = mix(grass.b, sand.b, sandT);

                        const rockStart = C.rockStart ?? heightAmp * 0.35;
                        const rockEnd =
                            rockStart + (C.rockSpan ?? heightAmp * 0.55);
                        const rockT = smoothstep01(rockStart, rockEnd, height);
                        lR = mix(lR, rock.r, rockT);
                        lG = mix(lG, rock.g, rockT);
                        lB = mix(lB, rock.b, rockT);

                        const snowH = C.snowHeight;
                        const snowByHeight = smoothstep01(
                            snowH,
                            snowH + heightAmp * 0.25,
                            height,
                        );
                        const snowByLat = smoothstep01(C.snowLat, 1.0, lat);
                        const snowMask = clamp01(
                            snowByHeight * (0.35 + 0.65 * snowByLat),
                        );
                        lR = mix(lR, snow.r, snowMask);
                        lG = mix(lG, snow.g, snowMask);
                        lB = mix(lB, snow.b, snowMask);

                        col[k] = mix(lR, wR, waterMask);
                        col[k + 1] = mix(lG, wG, waterMask);
                        col[k + 2] = mix(lB, wB, waterMask);

                        k += 3;
                    }
                }

                // skirts
                const edgeVerts = 4 * vertsPerSide;
                const skirtBase = vertCount;
                const totalVerts = vertCount + edgeVerts;

                const pos2 = new Float32Array(totalVerts * 3);
                const nrm2 = new Float32Array(totalVerts * 3);
                const col2 = new Float32Array(totalVerts * 3);
                pos2.set(pos, 0);
                nrm2.set(nrm, 0);
                col2.set(col, 0);

                function copySkirtEdge(getIndexFn, outOffsetVert) {
                    for (let t = 0; t <= N; t++) {
                        const baseIndex = getIndexFn(t);
                        const bi3 = baseIndex * 3;
                        const oi3 = (outOffsetVert + t) * 3;
                        const nx = nrm2[bi3],
                            ny = nrm2[bi3 + 1],
                            nz = nrm2[bi3 + 2];

                        pos2[oi3] = pos2[bi3] - nx * skirtDepth;
                        pos2[oi3 + 1] = pos2[bi3 + 1] - ny * skirtDepth;
                        pos2[oi3 + 2] = pos2[bi3 + 2] - nz * skirtDepth;

                        nrm2[oi3] = nx;
                        nrm2[oi3 + 1] = ny;
                        nrm2[oi3 + 2] = nz;
                        col2[oi3] = col2[bi3];
                        col2[oi3 + 1] = col2[bi3 + 1];
                        col2[oi3 + 2] = col2[bi3 + 2];
                    }
                }

                const topOff = skirtBase;
                const bottomOff = topOff + vertsPerSide;
                const leftOff = bottomOff + vertsPerSide;
                const rightOff = leftOff + vertsPerSide;

                copySkirtEdge((t) => 0 * vertsPerSide + t, topOff);
                copySkirtEdge((t) => N * vertsPerSide + t, bottomOff);
                copySkirtEdge((t) => t * vertsPerSide + 0, leftOff);
                copySkirtEdge((t) => t * vertsPerSide + N, rightOff);

                const IndexArray =
                    totalVerts > 65535 ? Uint32Array : Uint16Array;

                const quadCount = N * N;
                const mainIdx = new IndexArray(quadCount * 6);
                let ii = 0;
                for (let j = 0; j < N; j++) {
                    const row0 = j * vertsPerSide;
                    const row1 = (j + 1) * vertsPerSide;
                    for (let i = 0; i < N; i++) {
                        const a = row0 + i,
                            b = row0 + i + 1,
                            c = row1 + i,
                            d = row1 + i + 1;
                        mainIdx[ii++] = a;
                        mainIdx[ii++] = c;
                        mainIdx[ii++] = b;
                        mainIdx[ii++] = b;
                        mainIdx[ii++] = c;
                        mainIdx[ii++] = d;
                    }
                }

                const skirtTriCount = 4 * N * 2;
                const skirtIdx = new IndexArray(skirtTriCount * 3);
                let si = 0;
                function addSkirtStrip(baseGet, skirtGet) {
                    for (let t = 0; t < N; t++) {
                        const b0 = baseGet(t),
                            b1 = baseGet(t + 1);
                        const s0 = skirtGet(t),
                            s1 = skirtGet(t + 1);
                        skirtIdx[si++] = b0;
                        skirtIdx[si++] = s0;
                        skirtIdx[si++] = b1;
                        skirtIdx[si++] = b1;
                        skirtIdx[si++] = s0;
                        skirtIdx[si++] = s1;
                    }
                }
                addSkirtStrip(
                    (t) => 0 * vertsPerSide + t,
                    (t) => topOff + t,
                );
                addSkirtStrip(
                    (t) => N * vertsPerSide + t,
                    (t) => bottomOff + t,
                );
                addSkirtStrip(
                    (t) => t * vertsPerSide + 0,
                    (t) => leftOff + t,
                );
                addSkirtStrip(
                    (t) => t * vertsPerSide + N,
                    (t) => rightOff + t,
                );

                // Build TWO geometries so skirts can be rendered but not cast shadows.
                // Skirts can otherwise create huge hidden occluders that pollute shadow maps.
                // It's a pain for performance but I can't think of a better solution
                fixWindingOutward(mainIdx, pos2);
                fixWindingOutward(skirtIdx, pos2);

                const makeGeo = (idx) => {
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute(
                        "position",
                        new THREE.BufferAttribute(pos2, 3),
                    );
                    geo.setAttribute(
                        "normal",
                        new THREE.BufferAttribute(nrm2, 3),
                    );
                    geo.setAttribute(
                        "color",
                        new THREE.BufferAttribute(col2, 3),
                    );
                    geo.setIndex(new THREE.BufferAttribute(idx, 1));
                    geo.computeBoundingSphere();
                    return geo;
                };

                return {
                    main: makeGeo(mainIdx),
                    skirt: makeGeo(skirtIdx),
                };
            }

            ////////////////////////////////////////////////////////////////////////////////
            // Patch node
            ////////////////////////////////////////////////////////////////////////////////
            class PatchNode {
                constructor(body, face, level, u0, v0, u1, v1) {
                    this.body = body;
                    this.face = face;
                    this.level = level;
                    this.u0 = u0;
                    this.v0 = v0;
                    this.u1 = u1;
                    this.v1 = v1;
                    this.children = null;
                    this.meshMain = null;
                    this.meshSkirt = null;
                    this.boundCenter = new THREE.Vector3();
                    this.boundRadius = 1;
                    this._tmpWorldCenter = new THREE.Vector3();
                    this.computeBounds();
                }
                centerLocal(out) {
                    const u = (this.u0 + this.u1) * 0.5;
                    const v = (this.v0 + this.v1) * 0.5;
                    const c = faceUvToCube(this.face, u, v);
                    const d = cubeToCubesphereDir(c.x, c.y, c.z);
                    const r = this.body.radiusAtDir(d.x, d.y, d.z);
                    out.set(d.x * r, d.y * r, d.z * r);
                    return out;
                }
                computeBounds() {
                    this.centerLocal(this.boundCenter);
                    const baseR = this.body.cfg.baseRadius ?? 1400;
                    const patchSpan = 2 / (1 << this.level);
                    const approxEdgeLen = baseR * patchSpan;
                    const extra =
                        (this.body.heightAmp ?? 0) +
                        this.body.skirtDepthForLevel(this.level);
                    this.boundRadius = approxEdgeLen * 0.85 + extra;
                }
                ensureMesh() {
                    if (this.meshMain || this.meshSkirt) return;
                    const b = this.body;
                    const geos = buildPatchGeometry({
                        face: this.face,
                        u0: this.u0,
                        v0: this.v0,
                        u1: this.u1,
                        v1: this.v1,
                        gridN: b.patchGridN,
                        radiusAtDir: b.radiusAtDir,
                        sdf: b.sdf,
                        normalEps: b.normalEpsForLevel(this.level),
                        skirtDepth: b.skirtDepthForLevel(this.level),
                        baseRadius: b.baseRadius,
                        seaLevel: b.seaLevel,
                        heightAmp: b.heightAmp,
                        biome: b.biome,
                    });

                    // Main terrain surface: casts + receives shadows
                    this.meshMain = new THREE.Mesh(geos.main, b.terrainMat);
                    this.meshMain.castShadow = true;
                    this.meshMain.receiveShadow = true;
                    b.terrain.add(this.meshMain);

                    // Skirts: render to hide cracks, but DO NOT cast shadows (prevents shadow pollution)
                    this.meshSkirt = new THREE.Mesh(geos.skirt, b.terrainMat);
                    this.meshSkirt.castShadow = false;
                    this.meshSkirt.receiveShadow = true;
                    b.terrain.add(this.meshSkirt);
                }
                disposeMesh() {
                    if (this.meshMain) {
                        this.meshMain.geometry.dispose();
                        this.body.terrain.remove(this.meshMain);
                        this.meshMain = null;
                    }
                    if (this.meshSkirt) {
                        this.meshSkirt.geometry.dispose();
                        this.body.terrain.remove(this.meshSkirt);
                        this.meshSkirt = null;
                    }
                }
                split() {
                    if (this.children) return;
                    const um = (this.u0 + this.u1) * 0.5,
                        vm = (this.v0 + this.v1) * 0.5;
                    const L = this.level + 1,
                        f = this.face;
                    this.children = [
                        new PatchNode(
                            this.body,
                            f,
                            L,
                            this.u0,
                            this.v0,
                            um,
                            vm,
                        ),
                        new PatchNode(
                            this.body,
                            f,
                            L,
                            um,
                            this.v0,
                            this.u1,
                            vm,
                        ),
                        new PatchNode(
                            this.body,
                            f,
                            L,
                            this.u0,
                            vm,
                            um,
                            this.v1,
                        ),
                        new PatchNode(
                            this.body,
                            f,
                            L,
                            um,
                            vm,
                            this.u1,
                            this.v1,
                        ),
                    ];
                    this.disposeMesh();
                }
                merge() {
                    if (!this.children) return;
                    for (const c of this.children) c.destroy(true);
                    this.children = null;
                    this.ensureMesh();
                }
                destroy(recursive = false) {
                    if (recursive && this.children)
                        for (const c of this.children) c.destroy(true);
                    this.children = null;
                    this.disposeMesh();
                }
            }

            ////////////////////////////////////////////////////////////////////////////////
            // QuadSphere body
            ////////////////////////////////////////////////////////////////////////////////
            class QuadSphereBody {
                constructor(cfg) {
                    this.cfg = cfg;
                    this.group = new THREE.Group();

                    this.phase = cfg.phase ?? Math.random() * Math.PI * 2;
                    this.spinSpeed = (Math.PI * 2) / (cfg.dayLength ?? 1400);

                    this.terrain = new THREE.Group();
                    this.group.add(this.terrain);

                    const seed = (cfg.seed ?? 101010) | 0;
                    const baseRadius = cfg.baseRadius ?? 1400;
                    const heightAmp = cfg.heightAmp ?? 170;
                    const heightFreq = cfg.heightFreq ?? 2.0;

                    this.baseRadius = baseRadius;
                    this.heightAmp = heightAmp;

                    this.seaLevelOffset = cfg.seaLevelOffset ?? 0;

                    // Optional features (moons can disable ocean/atmosphere)
                    this.hasOcean = cfg.hasOcean !== false; // default true
                    this.hasAtmo = cfg.hasAtmo !== false; // default true

                    this.seaLevel = this.hasOcean
                        ? baseRadius + this.seaLevelOffset
                        : -1e9; // effectively "no ocean"

                    this.biome = {
                        seaLevel: this.seaLevel,
                        shoreWidth: cfg.shoreWidth ?? 20.0,
                        snowHeight: cfg.snowHeight ?? heightAmp * 0.55,
                        snowLat: cfg.snowLat ?? 0.55,
                        rockStart: cfg.rockStart ?? heightAmp * 0.35,
                        rockSpan: cfg.rockSpan ?? heightAmp * 0.55,
                        deepWater: new THREE.Color(cfg.deepWater ?? 0x061a2a),
                        shallowWater: new THREE.Color(
                            cfg.shallowWater ?? 0x1f5568,
                        ),
                        sand: new THREE.Color(cfg.sand ?? 0xd9c38a),
                        grass: new THREE.Color(cfg.grass ?? 0x2f6b34),
                        rock: new THREE.Color(cfg.rock ?? 0x666666),
                        snow: new THREE.Color(cfg.snow ?? 0xf7fbff),
                    };

                    this.terrainMat = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        vertexColors: true,
                        roughness: 0.98,
                        metalness: 0.0,
                        side: THREE.FrontSide,
                    });

                    // micro-variation
                    this.terrainMat.onBeforeCompile = (shader) => {
                        shader.vertexShader = shader.vertexShader.replace(
                            "#include <common>",
                            `#include <common>\nvarying vec3 vWorldPos;`,
                        );
                        shader.vertexShader = shader.vertexShader.replace(
                            "#include <begin_vertex>",
                            `#include <begin_vertex>\nvWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;`,
                        );
                        shader.fragmentShader = shader.fragmentShader.replace(
                            "#include <common>",
                            `#include <common>\nvarying vec3 vWorldPos;\nfloat hash13(vec3 p){p=fract(p*0.1031);p+=dot(p,p.yzx+33.33);return fract((p.x+p.y)*p.z);} `,
                        );
                        shader.fragmentShader = shader.fragmentShader.replace(
                            "#include <color_fragment>",
                            `#include <color_fragment>\nfloat n = hash13(vWorldPos * 0.015);\ndiffuseColor.rgb *= (0.90 + 0.20 * n);`,
                        );
                    };
                    this.terrainMat.needsUpdate = true;

                    // ocean waves material
                    const oceanMat = new THREE.MeshPhysicalMaterial({
                        color: cfg.oceanColor ?? 0x0b2a45,
                        roughness: 0.05,
                        metalness: 0.0,
                        transmission: 0.06,
                        thickness: 0.6,
                        transparent: true,
                        opacity: 0.84,
                        side: THREE.DoubleSide,
                    });

                    // Per-ocean occluder buffers (can’t be shared across bodies like atmo passes).
                    // Matches the atmosphere eclipse cap (24).
                    this._oceanOccCenters = new Float32Array(24 * 3);
                    this._oceanOccRadii = new Float32Array(24);

                    oceanMat.onBeforeCompile = (shader) => {
                        shader.uniforms.uTime = { value: 0 };
                        shader.uniforms.uWaveAmp = {
                            value: cfg.waveAmp ?? 2.6,
                        };
                        shader.uniforms.uWaveFreq = {
                            value: cfg.waveFreq ?? 0.014,
                        };
                        shader.uniforms.uWaveSpeed = {
                            value: cfg.waveSpeed ?? 0.65,
                        };
                        shader.uniforms.uMurk = {
                            value: cfg.oceanMurk ?? 0.55,
                        };

                        shader.uniforms.uPlanetCenterW = {
                            value: new THREE.Vector3(),
                        };
                        shader.uniforms.uSunPosW = {
                            value: new THREE.Vector3(),
                        };
                        shader.uniforms.uNightDarken = { value: 3.2 };
                        shader.uniforms.uMinLight = { value: 0.02 };

                        // Eclipse occluders (same interface as atmospheres)
                        shader.uniforms.uOccCount = { value: 0 };
                        shader.uniforms.uOccCenters = {
                            value: this._oceanOccCenters,
                        };
                        shader.uniforms.uOccRadii = {
                            value: this._oceanOccRadii,
                        };
                        shader.uniforms.uEclipseSoftness = { value: 0.015 };
                        shader.uniforms.uEclipseStrength = { value: 1.0 };

                        shader.vertexShader = shader.vertexShader.replace(
                            "#include <common>",
                            `#include <common>
uniform float uTime;
uniform float uWaveAmp;
uniform float uWaveFreq;
uniform float uWaveSpeed;

varying vec3 vWorldPos;
varying vec3 vWavyNormal;

float waveFn(vec3 p){
  float t = uTime * uWaveSpeed;
  float w1 = sin((p.x + p.z) * uWaveFreq + t);
  float w2 = sin((p.x*0.7 - p.z*1.3) * (uWaveFreq*1.7) + t*1.35);
  float w3 = sin((p.x*1.9 + p.z*0.6) * (uWaveFreq*2.3) + t*1.9);
  return (w1*0.55 + w2*0.30 + w3*0.15);
}`,
                        );

                        shader.vertexShader = shader.vertexShader.replace(
                            "#include <begin_vertex>",
                            `#include <begin_vertex>
vec3 wp0 = (modelMatrix * vec4(position, 1.0)).xyz;
float h = waveFn(wp0);

transformed += normalize(position) * (h * uWaveAmp);

vec3 wp = (modelMatrix * vec4(transformed, 1.0)).xyz;
vWorldPos = wp;

vec3 dx = vec3(1.0, 0.0, 0.0);
vec3 dz = vec3(0.0, 0.0, 1.0);
float hx = waveFn(wp + dx*35.0) - waveFn(wp - dx*35.0);
float hz = waveFn(wp + dz*35.0) - waveFn(wp - dz*35.0);

vec3 n = normalize(normalMatrix * normal);
vWavyNormal = normalize(n + vec3(-hx, 0.0, -hz) * 0.18);`,
                        );

                        shader.fragmentShader = shader.fragmentShader.replace(
                            "#include <common>",
                            `#include <common>
	uniform float uTime;
	uniform float uMurk;

	uniform vec3 uPlanetCenterW;
	uniform vec3 uSunPosW;
		uniform float uNightDarken;
		uniform float uMinLight;

	uniform int   uOccCount;
	uniform vec3  uOccCenters[24];
	uniform float uOccRadii[24];
	uniform float uEclipseSoftness;
	uniform float uEclipseStrength;

		float gNightMask;
		float gEclipseDim;

	float raySphereHit(vec3 ro, vec3 rd, vec3 c, float r){
	  vec3 oc = ro - c;
	  float b = dot(oc, rd);
	  float c0 = dot(oc, oc) - r*r;
	  float h = b*b - c0;
	  if(h < 0.0) return 1e9;
	  h = sqrt(h);
	  float t0 = -b - h;
	  float t1 = -b + h;
	  if(t0 > 0.0) return t0;
	  if(t1 > 0.0) return t1;
	  return 1e9;
	}

	float sunVisibility(vec3 pW, vec3 sunPosW){
	  vec3 rd = normalize(sunPosW - pW);
	  float maxT = length(sunPosW - pW);
	  float vis = 1.0;
	  for(int i=0; i<24; i++){
	    if(i >= uOccCount) break;
	    float tHit = raySphereHit(pW, rd, uOccCenters[i], uOccRadii[i]);
	    if(tHit < maxT){
	      vec3 oc = pW - uOccCenters[i];
	      float b = dot(oc, rd);
	      float d2 = dot(oc, oc) - b*b;
	      float d = sqrt(max(d2, 0.0));
	      float r = uOccRadii[i];
	      float edge = smoothstep(r, r + r*uEclipseSoftness, d);
	      vis = min(vis, edge);
	    }
	  }
	  return mix(1.0, vis, clamp(uEclipseStrength, 0.0, 1.0));
	}

	varying vec3 vWorldPos;
	varying vec3 vWavyNormal;`,
                        );

                        shader.fragmentShader = shader.fragmentShader.replace(
                            "#include <color_fragment>",
                            `#include <color_fragment>
	vec3 sunDir = normalize(uSunPosW - uPlanetCenterW);
	vec3 upP = normalize(vWorldPos - uPlanetCenterW);
	float day = clamp(dot(upP, sunDir) * 0.5 + 0.5, 0.0, 1.0);
	float nightMask = mix(uMinLight, 1.0, pow(day, uNightDarken));

	// Eclipse dim (matches atmosphere behavior)
	float vis = sunVisibility(vWorldPos, uSunPosW);
		float eclipseDim = mix(1.0, 0.45, 1.0 - vis);
	nightMask *= eclipseDim;
		gEclipseDim = eclipseDim;

	gNightMask = nightMask;
	diffuseColor.rgb *= nightMask;`,
                        );

                        shader.fragmentShader = shader.fragmentShader.replace(
                            "#include <lights_fragment_begin>",
                            `#include <lights_fragment_begin>
	vec3 V = normalize(cameraPosition - vWorldPos);
	float fres = pow(1.0 - max(dot(normalize(vWavyNormal), V), 0.0), 3.0);

	vec3 murkCol = vec3(0.03, 0.10, 0.14);
	diffuseColor.rgb = mix(diffuseColor.rgb, murkCol, uMurk);
	// Keep the rim/glint from blowing out at night or during eclipses
	diffuseColor.rgb += fres * 0.16 * gNightMask;`,
                        );

                        // Dim direct sunlight on the ocean during eclipses (affects specular too).
                        shader.fragmentShader = shader.fragmentShader.replace(
                            "#include <lights_fragment_end>",
                            `#include <lights_fragment_end>
	reflectedLight.directDiffuse *= gEclipseDim;
	reflectedLight.directSpecular *= gEclipseDim;`,
                        );

                        oceanMat.userData.shader = shader;
                    };

                    if (this.hasOcean) {
                        this.ocean = new THREE.Mesh(
                            new THREE.SphereGeometry(this.seaLevel, 72, 36),
                            oceanMat,
                        );
                        this.ocean.receiveShadow = true;
                        this.ocean.castShadow = false;
                        this.group.add(this.ocean);
                    } else {
                        this.ocean = null;
                    }

                    const seabedDepth = cfg.seabedDepth ?? heightAmp * 0.2;

                    this.radiusAtDir = (dx, dy, dz) => {
                        const h = fbm3Seeded(
                            dx * heightFreq,
                            dy * heightFreq,
                            dz * heightFreq,
                            seed + 17,
                            5,
                            2.1,
                            0.52,
                        );
                        const raw = baseRadius + heightAmp * h;
                        return Math.max(raw, this.seaLevel - seabedDepth);
                    };

                    this.sdf = makePlanetSdf(this.radiusAtDir);

                    // Far mesh (cheap LOD): low-poly displaced + vertex biome colors.
                    // This prevents distant moons from looking like flat grey spheres.
                    const farGeo = new THREE.IcosahedronGeometry(
                        baseRadius,
                        cfg.farDetail ?? 2,
                    );
                    {
                        const posAttr = farGeo.getAttribute("position");
                        const pos = posAttr.array;
                        const col = new Float32Array(posAttr.count * 3);

                        const C = this.biome;
                        const deepW = C.deepWater,
                            shallowW = C.shallowWater,
                            sand = C.sand,
                            grass = C.grass,
                            rock = C.rock,
                            snow = C.snow;

                        for (let vi = 0; vi < posAttr.count; vi++) {
                            const i3 = vi * 3;
                            let dx = pos[i3],
                                dy = pos[i3 + 1],
                                dz = pos[i3 + 2];
                            const invLen =
                                1.0 / Math.max(1e-8, Math.hypot(dx, dy, dz));
                            dx *= invLen;
                            dy *= invLen;
                            dz *= invLen;

                            const r = this.radiusAtDir(dx, dy, dz);
                            pos[i3] = dx * r;
                            pos[i3 + 1] = dy * r;
                            pos[i3 + 2] = dz * r;

                            const height = r - baseRadius;
                            const lat = Math.abs(dy);
                            const shoreW = C.shoreWidth;
                            const aboveSea = r - this.seaLevel;

                            const waterMask =
                                1.0 - smoothstep01(-shoreW, +shoreW, aboveSea);

                            const shallowT = smoothstep01(
                                -shoreW * 1.0,
                                -shoreW * 0.15,
                                aboveSea,
                            );
                            let wR = mix(deepW.r, shallowW.r, shallowT);
                            let wG = mix(deepW.g, shallowW.g, shallowT);
                            let wB = mix(deepW.b, shallowW.b, shallowT);

                            const sandT =
                                1.0 - smoothstep01(0.0, shoreW * 1.2, aboveSea);
                            let lR = mix(grass.r, sand.r, sandT);
                            let lG = mix(grass.g, sand.g, sandT);
                            let lB = mix(grass.b, sand.b, sandT);

                            const rockStart = C.rockStart ?? heightAmp * 0.35;
                            const rockEnd =
                                rockStart + (C.rockSpan ?? heightAmp * 0.55);
                            const rockT = smoothstep01(
                                rockStart,
                                rockEnd,
                                height,
                            );
                            lR = mix(lR, rock.r, rockT);
                            lG = mix(lG, rock.g, rockT);
                            lB = mix(lB, rock.b, rockT);

                            const snowH = C.snowHeight;
                            const snowByHeight = smoothstep01(
                                snowH,
                                snowH + heightAmp * 0.25,
                                height,
                            );
                            const snowByLat = smoothstep01(C.snowLat, 1.0, lat);
                            const snowMask = clamp01(
                                snowByHeight * (0.35 + 0.65 * snowByLat),
                            );
                            lR = mix(lR, snow.r, snowMask);
                            lG = mix(lG, snow.g, snowMask);
                            lB = mix(lB, snow.b, snowMask);

                            col[i3] = mix(lR, wR, waterMask);
                            col[i3 + 1] = mix(lG, wG, waterMask);
                            col[i3 + 2] = mix(lB, wB, waterMask);
                        }

                        farGeo.setAttribute(
                            "color",
                            new THREE.BufferAttribute(col, 3),
                        );
                        farGeo.computeVertexNormals();
                        posAttr.needsUpdate = true;
                    }

                    this.farMesh = new THREE.Mesh(
                        farGeo,
                        new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            vertexColors: true,
                            roughness: 0.98,
                            metalness: 0.0,
                            side: THREE.FrontSide,
                        }),
                    );
                    this.farMesh.castShadow = true;
                    this.farMesh.receiveShadow = true;
                    this.group.add(this.farMesh);

                    this.patchGridN = cfg.patchGridN ?? 12;
                    this.maxLevel = cfg.maxLevel ?? 9;
                    this.splitBudgetPerFrame = cfg.splitBudgetPerFrame ?? 6;
                    this.mergeBudgetPerFrame = cfg.mergeBudgetPerFrame ?? 6;
                    this.baseSplitFactor = cfg.baseSplitFactor ?? 9.2;
                    this.baseMergeFactor = cfg.baseMergeFactor ?? 14.2;

                    this.activeDist = cfg.activeDist ?? baseRadius * 26.0;
                    this.lodDist = cfg.lodDist ?? baseRadius * 18.0;
                    this.nodeCullFactor = cfg.nodeCullFactor ?? 2.2;

                    this.roots = [];
                    for (let f = 0; f < 6; f++)
                        this.roots.push(
                            new PatchNode(this, f, 0, -1, -1, 1, 1),
                        );

                    this._frustum = new THREE.Frustum();
                    this._projView = new THREE.Matrix4();
                    this._sphereWorld = new THREE.Sphere(
                        new THREE.Vector3(),
                        1,
                    );

                    this._tmpCenter = new THREE.Vector3();
                    this._invMat = new THREE.Matrix4();
                    this._camLocal = new THREE.Vector3();
                    this._camWorld = new THREE.Vector3();
                    this._tmpQ = new THREE.Quaternion();

                    this.terrainActive = true;
                    this.terrain.visible = true;
                    this.farMesh.visible = false;
                    for (const r of this.roots) r.ensureMesh();

                    this.prevPos = new THREE.Vector3();
                    this.prevQuat = new THREE.Quaternion();
                    this.currPos = new THREE.Vector3();
                    this.currQuat = new THREE.Quaternion();
                    this.prevPos.copy(this.group.position);
                    this.currPos.copy(this.group.position);
                    this.prevQuat.copy(this.group.quaternion);
                    this.currQuat.copy(this.group.quaternion);

                    this.index = -1; // filled by addPlanet()
                }

                beginFrameCapture() {
                    this.group.updateMatrixWorld(true);
                    this.group.getWorldPosition(this.prevPos);
                    this.group.getWorldQuaternion(this.prevQuat);
                }
                endFrameCapture() {
                    this.group.updateMatrixWorld(true);
                    this.group.getWorldPosition(this.currPos);
                    this.group.getWorldQuaternion(this.currQuat);
                }

                updateOrbit(dt) {
                    if (!this.cfg.orbitDist) return;
                    this.phase += dt * (this.cfg.orbitSpeed ?? 0.006);
                    const x = Math.cos(this.phase) * this.cfg.orbitDist;
                    const z = Math.sin(this.phase) * this.cfg.orbitDist;
                    this.group.position.set(x, 0, z);
                    this.group.rotation.y += this.spinSpeed * dt;
                }

                setTerrainActive(on) {
                    if (this.terrainActive === on) return;
                    this.terrainActive = on;
                    this.terrain.visible = on;
                    this.farMesh.visible = !on;
                    if (!on) this.forceRootsOnly();
                    else for (const r of this.roots) r.ensureMesh();
                }
                forceRootsOnly() {
                    for (const r of this.roots) {
                        if (r.children) r.merge();
                        r.ensureMesh();
                    }
                }

                normalEpsForLevel(level) {
                    const baseR = this.cfg.baseRadius ?? 1400;
                    const patchSpan = 2 / (1 << level);
                    const approxEdgeLen = baseR * patchSpan;
                    return Math.max(
                        0.55,
                        (approxEdgeLen / this.patchGridN) * 0.33,
                    );
                }
                skirtDepthForLevel(level) {
                    const baseR = this.cfg.baseRadius ?? 1400;
                    const patchSpan = 2 / (1 << level);
                    const approxEdgeLen = baseR * patchSpan;
                    return THREE.MathUtils.clamp(
                        approxEdgeLen * 0.085,
                        6.0,
                        140.0,
                    );
                }

                wantSplit(node, cameraLocal) {
                    const baseR = this.cfg.baseRadius ?? 1400;
                    const patchSpan = 2 / (1 << node.level);
                    const approxEdgeLen = baseR * patchSpan;
                    node.centerLocal(this._tmpCenter);
                    const d = this._tmpCenter.distanceTo(cameraLocal);
                    return d < approxEdgeLen * this.baseSplitFactor;
                }
                wantMerge(node, cameraLocal) {
                    const baseR = this.cfg.baseRadius ?? 1400;
                    const patchSpan = 2 / (1 << node.level);
                    const approxEdgeLen = baseR * patchSpan;
                    node.centerLocal(this._tmpCenter);
                    const d = this._tmpCenter.distanceTo(cameraLocal);
                    return d > approxEdgeLen * this.baseMergeFactor;
                }
                nodeWorthTraversing(node, cameraLocal) {
                    const baseR = this.cfg.baseRadius ?? 1400;
                    const patchSpan = 2 / (1 << node.level);
                    const approxEdgeLen = baseR * patchSpan;
                    node.centerLocal(this._tmpCenter);
                    const d = this._tmpCenter.distanceTo(cameraLocal);
                    return (
                        d <
                        approxEdgeLen *
                            (this.baseMergeFactor * this.nodeCullFactor)
                    );
                }
                nodeInFrustum(node) {
                    node._tmpWorldCenter
                        .copy(node.boundCenter)
                        .applyMatrix4(this.group.matrixWorld);
                    this._sphereWorld.center.copy(node._tmpWorldCenter);
                    this._sphereWorld.radius = node.boundRadius;
                    return this._frustum.intersectsSphere(this._sphereWorld);
                }

                updateLOD(cameraWorldPos, camera) {
                    if (!this.terrainActive) return;

                    this._camWorld.copy(cameraWorldPos);
                    this.group.updateMatrixWorld(true);
                    this._invMat.copy(this.group.matrixWorld).invert();
                    this._camLocal
                        .copy(cameraWorldPos)
                        .applyMatrix4(this._invMat);

                    camera.updateMatrixWorld(true);
                    this._projView.multiplyMatrices(
                        camera.projectionMatrix,
                        camera.matrixWorldInverse,
                    );
                    this._frustum.setFromProjectionMatrix(this._projView);

                    let splitBudget = this.splitBudgetPerFrame;
                    let mergeBudget = this.mergeBudgetPerFrame;

                    const stack = [...this.roots];
                    while (stack.length) {
                        const n = stack.pop();

                        if (!this.nodeInFrustum(n)) {
                            if (n.children) n.merge();
                            else n.ensureMesh();
                            continue;
                        }
                        if (!this.nodeWorthTraversing(n, this._camLocal)) {
                            if (n.children) n.merge();
                            else n.ensureMesh();
                            continue;
                        }

                        if (n.children) {
                            if (
                                mergeBudget > 0 &&
                                n.level >= 1 &&
                                this.wantMerge(n, this._camLocal)
                            ) {
                                n.merge();
                                mergeBudget--;
                            } else {
                                for (const c of n.children) stack.push(c);
                            }
                        } else {
                            if (
                                splitBudget > 0 &&
                                n.level < this.maxLevel &&
                                this.wantSplit(n, this._camLocal)
                            ) {
                                n.split();
                                splitBudget--;
                                if (n.children)
                                    for (const c of n.children) c.ensureMesh();
                            } else {
                                n.ensureMesh();
                            }
                        }
                    }
                }

                destroy() {
                    for (const r of this.roots) r.destroy(true);
                    if (this.ocean) {
                        this.ocean.geometry.dispose();
                        this.ocean.material.dispose();
                    }
                    this.farMesh.geometry.dispose();
                    this.farMesh.material.dispose();
                    this.terrainMat.dispose();
                }
            }

            ////////////////////////////////////////////////////////////////////////////////
            // THREE setup
            ////////////////////////////////////////////////////////////////////////////////
            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                logarithmicDepthBuffer: true,
            });

            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = true;

            renderer.autoClear = false;
            renderer.autoClearColor = false;
            renderer.autoClearDepth = false;
            renderer.autoClearStencil = false;
            renderer.toneMapping = THREE.NoToneMapping;
            renderer.toneMappingExposure = 1.0;

            renderer.domElement.style.display = "block";
            renderer.domElement.tabIndex = 0;
            document.body.appendChild(renderer.domElement);

            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.000012);

            const camera = new THREE.PerspectiveCamera(
                75,
                innerWidth / innerHeight,
                0.05,
                260000,
            );
            scene.add(camera);

            // Lights
            const hemi = new THREE.HemisphereLight(0xcfe3ff, 0x04070c, 0.25);
            scene.add(hemi);

            const msg = document.getElementById("msg");
            const crosshair = document.getElementById("crosshair");

            const fpsEl = document.getElementById("fps");
            let fpsFrames = 0;
            let fpsAccum = 0;
            let fpsLast = performance.now();

            const qualitySel = document.getElementById("qualitySelect");
            const QUALITY_PRESETS = {
                Potato: {
                    pointShadow: 256,
                    spotShadow: 512,
                    atmoScale: 0.5,
                    cloudScale: 0.25,
                    godRaySamples: 12,
                    atmoSteps: 12,
                    cloudSteps: 8,
                    cloudLightSteps: 2,
                },
                Laptop: {
                    pointShadow: 512,
                    spotShadow: 1024,
                    atmoScale: 0.67,
                    cloudScale: 0.5,
                    godRaySamples: 16,
                    atmoSteps: 16,
                    cloudSteps: 12,
                    cloudLightSteps: 4,
                },
                Descktop: {
                    pointShadow: 1024,
                    spotShadow: 2048,
                    atmoScale: 1.0,
                    cloudScale: 0.5,
                    godRaySamples: 24,
                    atmoSteps: 20,
                    cloudSteps: 16,
                    cloudLightSteps: 6,
                },
                GamingPC: {
                    pointShadow: 2048,
                    spotShadow: 4096,
                    atmoScale: 1.0,
                    cloudScale: 0.5,
                    godRaySamples: 48,
                    atmoSteps: 24,
                    cloudSteps: 22,
                    cloudLightSteps: 8,
                },
                NASA: {
                    pointShadow: 4096,
                    spotShadow: 8192,
                    atmoScale: 1.0,
                    cloudScale: 1.0,
                    godRaySamples: 64,
                    atmoSteps: 30,
                    cloudSteps: 26,
                    cloudLightSteps: 10,
                },
            };

            let currentQuality =
                qualitySel && QUALITY_PRESETS[qualitySel.value]
                    ? qualitySel.value
                    : "Descktop";

            let QUALITY_POINT_SHADOW =
                QUALITY_PRESETS[currentQuality].pointShadow;
            let QUALITY_SPOT_SHADOW =
                QUALITY_PRESETS[currentQuality].spotShadow;
            let QUALITY_ATMO_SCALE = QUALITY_PRESETS[currentQuality].atmoScale;
            let QUALITY_CLOUD_SCALE =
                QUALITY_PRESETS[currentQuality].cloudScale;
            let QUALITY_GODRAY_SAMPLES =
                QUALITY_PRESETS[currentQuality].godRaySamples;
            let QUALITY_ATMO_STEPS = QUALITY_PRESETS[currentQuality].atmoSteps;
            let QUALITY_CLOUD_STEPS =
                QUALITY_PRESETS[currentQuality].cloudSteps;
            let QUALITY_CLOUD_LIGHT_STEPS =
                QUALITY_PRESETS[currentQuality].cloudLightSteps;

            // const galaxyOverlay = document.getElementById("galaxyOverlay");
            const galaxyFull = document.getElementById("galaxyFull");
            const gctx = galaxyFull.getContext("2d", { alpha: false });

            let galaxyOpen = false;

            // Galaxy location of the CURRENT system (separate from local world coords)
            const galaxyPlayer = { x: 0, z: 0, name: "SOL-000" };

            // Galaxy params (map space)
            const GALAXY_RADIUS = 2500000; // tune
            const GALAXY_SEED = 133742069;
            const STAR_COUNT = 2000; // tune 2k–20k
            const CELL = 25000; // spatial cell size

            let GALAXY_DOUBLE_SPIRAL = true;
            const GALAXY_ARMS = 4;
            const ARM_TIGHTNESS = 1.3; // higher = tighter spiral
            const ARM_WIDTH = 1.3; // lower = thinner arms
            const CORE_BIAS = -0.5; // more stars near core

            const BULGE_FRACTION = 0.175; // % of stars that belong to the core bulge
            const BULGE_RADIUS = 0.2; // relative to GALAXY_RADIUS (0.12–0.25)
            const BULGE_FLATTEN = 0.55; // <1 makes an elliptical blob (Milky Way-ish)
            const BULGE_ROT = 0.35; // radians: rotate the bulge ellipse a bit

            const HAZE_RADIUS_UNITS = GALAXY_RADIUS * 3.0; // glow size relative to the whole galaxy

            let gPanX = 0,
                gPanZ = 0;
            let gZoom = 1.0; // zoom multiplier
            let gSelected = -1;

            const galaxyStars = []; //
            const gGrid = new Map(); // key -> indices
            const gKey = (ix, iz) => (ix << 16) ^ (iz & 0xffff);

            function mulberry32_g(a) {
                return function () {
                    a |= 0;
                    a = (a + 0x6d2b79f5) | 0;
                    let t = Math.imul(a ^ (a >>> 15), 1 | a);
                    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
                    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                };
            }

            function genGalaxy() {
                galaxyStars.length = 0;
                gGrid.clear();

                const rnd = mulberry32_g(GALAXY_SEED);

                for (let i = 0; i < STAR_COUNT; i++) {
                    // radius: bias toward core a bit
                    // u^p -> more weight near 0, then sqrt for disk area feel
                    // const u = rnd();
                    // const r =
                    //     Math.sqrt(Math.pow(u, 1.0 - CORE_BIAS)) * GALAXY_RADIUS;

                    // // thickness/jitter (small)
                    // const jitter = (rnd() - 0.5) * (GALAXY_RADIUS * 0.02);

                    let x, z;

                    const inBulge = rnd() < BULGE_FRACTION;

                    if (inBulge) {
                        // Elliptical Gaussian-ish bulge (a "blob")
                        // radius distribution: more weight near center
                        const u1 = Math.max(1e-6, rnd());
                        const u2 = rnd();
                        const theta = u2 * Math.PI * 2;

                        // "Gaussian" radius via sqrt(-ln(u))
                        const rr =
                            Math.sqrt(-Math.log(u1)) *
                            (GALAXY_RADIUS * BULGE_RADIUS);

                        // ellipse axes
                        let bx = Math.cos(theta) * rr;
                        let bz = Math.sin(theta) * rr * BULGE_FLATTEN;

                        // rotate ellipse
                        const cs = Math.cos(BULGE_ROT),
                            sn = Math.sin(BULGE_ROT);
                        const rx = bx * cs - bz * sn;
                        const rz = bx * sn + bz * cs;

                        x = rx;
                        z = rz;
                    } else if (GALAXY_DOUBLE_SPIRAL) {
                        // Arms
                        const u = rnd();
                        const r =
                            Math.sqrt(Math.pow(u, 1.0 - CORE_BIAS)) *
                            GALAXY_RADIUS;

                        const armIndex = (rnd() * GALAXY_ARMS) | 0;
                        const armBase = (armIndex / GALAXY_ARMS) * Math.PI * 2;

                        const spiralAngle =
                            armBase +
                            (r / GALAXY_RADIUS) * ARM_TIGHTNESS * Math.PI * 2;

                        const spread =
                            (rnd() - 0.5) *
                            ARM_WIDTH *
                            (0.35 + 0.65 * (r / GALAXY_RADIUS));

                        const a = spiralAngle + spread;

                        x = Math.cos(a) * r;
                        z = Math.sin(a) * r;

                        // extra clumping along arms
                        const clump = (rnd() - 0.5) * (GALAXY_RADIUS * 0.01);
                        x += clump * Math.cos(a * 3.0 + 10.0);
                        z += clump * Math.sin(a * 3.0 + 10.0);
                    } else {
                        // disk fallback
                        const u = rnd();
                        const r =
                            Math.sqrt(Math.pow(u, 1.0 - CORE_BIAS)) *
                            GALAXY_RADIUS;
                        const a = rnd() * Math.PI * 2;
                        x = Math.cos(a) * r;
                        z = Math.sin(a) * r;
                    }

                    // thinner disk fuzz (applies to arms + bulge)
                    const jitter = (rnd() - 0.5) * (GALAXY_RADIUS * 0.012);
                    x += jitter;
                    z += jitter;

                    // spectral-ish color
                    const t = rnd();
                    let col = "rgba(255,255,255,";
                    if (t < 0.08) col = "rgba(170,200,255,";
                    else if (t < 0.25) col = "rgba(210,230,255,";
                    else if (t < 0.7) col = "rgba(255,245,230,";
                    else col = "rgba(255,210,170,";

                    // brightness: few bright, many dim
                    const mag = Math.pow(rnd(), 3.2);

                    const idx = galaxyStars.length;
                    galaxyStars.push({ x, z, col, mag });

                    // spatial grid insert
                    const ix = Math.floor(x / CELL);
                    const iz = Math.floor(z / CELL);
                    const k = gKey(ix, iz);
                    let arr = gGrid.get(k);
                    if (!arr) gGrid.set(k, (arr = []));
                    arr.push(idx);
                }
            }

            genGalaxy();

            function resizeGalaxyFull() {
                const dpr = Math.max(1, devicePixelRatio || 1);
                galaxyFull.width = Math.floor(innerWidth * dpr);
                galaxyFull.height = Math.floor(innerHeight * dpr);
                gctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
            }
            addEventListener("resize", () => {
                if (galaxyOpen) resizeGalaxyFull();
            });

            function openGalaxyMap() {
                galaxyOpen = true;
                galaxyOverlay.classList.remove("off");
                resizeGalaxyFull();

                // leave pointer lock so mouse works for the map
                if (document.pointerLockElement) document.exitPointerLock();
                pointerLocked = false;
                crosshair?.classList.remove("on");
                mouseDX = 0;
                mouseDY = 0;

                // start centered on current system
                gPanX = galaxyPlayer.x;
                gPanZ = galaxyPlayer.z;
            }

            function closeGalaxyMap() {
                galaxyOpen = false;
                galaxyOverlay.classList.add("off");
            }

            // Toggle with G, close with Esc
            addEventListener("keydown", (e) => {
                if (e.code === "KeyG") {
                    if (galaxyOpen) closeGalaxyMap();
                    else openGalaxyMap();
                }
                if (galaxyOpen && e.code === "Escape") closeGalaxyMap();
                if (galaxyOpen && e.code === "Enter") {
                    // center on player (using world XZ as galaxy proxy)
                    const px = galaxyPlayer.x;
                    const pz = galaxyPlayer.z;
                    gPanX = px;
                    gPanZ = pz;
                }
            });

            // Mouse pan + wheel zoom + click select
            let dragging = false;
            let lastMX = 0,
                lastMY = 0;

            galaxyFull.addEventListener("mousedown", (e) => {
                dragging = true;
                lastMX = e.clientX;
                lastMY = e.clientY;
            });

            addEventListener("mouseup", () => {
                dragging = false;
            });

            addEventListener("mousemove", (e) => {
                if (!galaxyOpen || !dragging) return;

                const dx = e.clientX - lastMX;
                const dy = e.clientY - lastMY;
                lastMX = e.clientX;
                lastMY = e.clientY;

                // convert pixels -> galaxy units
                const unitsPerPixel = galaxyUnitsPerPixel();
                gPanX -= dx * unitsPerPixel;
                gPanZ -= dy * unitsPerPixel;
            });

            galaxyFull.addEventListener(
                "wheel",
                (e) => {
                    if (!galaxyOpen) return;
                    e.preventDefault();

                    const zoomFactor = Math.pow(1.12, -Math.sign(e.deltaY));
                    gZoom = Math.min(40.0, Math.max(0.08, gZoom * zoomFactor));
                },
                { passive: false },
            );

            // keep these outside the listener (module/global scope)
            let gLastClickStar = -1;
            let gLastClickTime = 0;
            const DOUBLE_CLICK_MS = 350;

            galaxyFull.addEventListener("click", (e) => {
                if (!galaxyOpen) return;

                const mx = e.clientX;
                const my = e.clientY;
                const unitsPerPixel = galaxyUnitsPerPixel();
                const gx = gPanX + (mx - innerWidth * 0.5) * unitsPerPixel;
                const gz = gPanZ + (my - innerHeight * 0.5) * unitsPerPixel;

                // search nearby cells only
                const ix = Math.floor(gx / CELL);
                const iz = Math.floor(gz / CELL);

                let best = -1;
                let bestD2 = Infinity;

                for (let dz = -1; dz <= 1; dz++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const arr = gGrid.get(gKey(ix + dx, iz + dz));
                        if (!arr) continue;
                        for (const id of arr) {
                            const s = galaxyStars[id];
                            const dxg = s.x - gx;
                            const dzg = s.z - gz;
                            const d2 = dxg * dxg + dzg * dzg;
                            if (d2 < bestD2) {
                                bestD2 = d2;
                                best = id;
                            }
                        }
                    }
                }

                // only select if reasonably close on screen
                const maxPick = (15 * unitsPerPixel) ** 2;

                // miss -> reset the "double click armed" state
                if (!(best >= 0 && bestD2 <= maxPick)) {
                    gLastClickStar = -1;
                    gLastClickTime = 0;
                    return;
                }

                // select the star
                gSelected = best;

                // double click on the SAME star = two clicks within DOUBLE_CLICK_MS
                const now = performance.now();
                if (
                    best === gLastClickStar &&
                    now - gLastClickTime <= DOUBLE_CLICK_MS
                ) {
                    const s = galaxyStars[best];

                    const nx = s.x / GALAXY_RADIUS;
                    const ny = s.z / GALAXY_RADIUS;

                    const targetDesc = {
                        name: `STAR-${String(best).padStart(3, "0")}`,
                        seed: (GALAXY_SEED ^ (best * 2654435761)) >>> 0,
                        // normalized (for external use)
                        x: nx,
                        y: ny,
                        // absolute galaxy units (for this map)
                        gx: s.x,
                        gz: s.z,
                    };

                    if (typeof warpCtrl !== "undefined" && warpCtrl?.start) {
                        // Warp is only allowed in fly mode; if walking, do nothing.
                        // TODO: Maybe close the map, or show a "Fly mode only" message
                        try {
                            if (player?.mode !== "fly") {
                                gLastClickStar = -1;
                                gLastClickTime = 0;
                                return;
                            }
                        } catch (e) {
                            return;
                        }

                        const started = warpCtrl.start(targetDesc);

                        if (started) {
                            // consume so triple-click doesn't retrigger instantly
                            gLastClickStar = -1;
                            gLastClickTime = 0;
                            closeGalaxyMap();
                        }
                    } else {
                        // No warp system in this build — just center the map on the selected star.
                        gPanX = s.x;
                        gPanZ = s.z;
                        msg.textContent = `Selected ${targetDesc.name} (warp not enabled in this build).`;

                        gLastClickStar = -1;
                        gLastClickTime = 0;
                    }
                    return;
                }

                // arm for the next click
                gLastClickStar = best;
                gLastClickTime = now;
            });

            function galaxyUnitsPerPixel() {
                // lower => zoomed in (more detail)
                const base =
                    GALAXY_RADIUS / (Math.min(innerWidth, innerHeight) * 0.6);
                return base / gZoom;
            }

            function drawGalaxyFull() {
                if (!galaxyOpen) return;

                const w = innerWidth,
                    h = innerHeight;
                const cx = w * 0.5,
                    cy = h * 0.5;

                // background
                gctx.clearRect(0, 0, w, h);
                gctx.fillStyle = "rgba(0,0,0,1)";
                gctx.fillRect(0, 0, w, h);

                // vignette
                const R = Math.min(w, h) * 0.55;
                const grad = gctx.createRadialGradient(cx, cy, 0, cx, cy, R);
                grad.addColorStop(0.0, "rgba(0,0,0,0.0)");
                grad.addColorStop(1.0, "rgba(0,0,0,0.6)");
                gctx.fillStyle = grad;
                gctx.fillRect(0, 0, w, h);

                // Subtle galaxy background glow that scales with the galaxy
                {
                    const w = innerWidth,
                        h = innerHeight;
                    const cx = w * 0.5,
                        cy = h * 0.5;

                    const upp = galaxyUnitsPerPixel(); // galaxy units per pixel
                    const coreX = cx + (0 - gPanX) / upp;
                    const coreY = cy + (0 - gPanZ) / upp;

                    // Convert galaxy-space radius -> screen-space pixels
                    let Rpx = HAZE_RADIUS_UNITS / upp;

                    // Clamp so it doesn't get ridiculous when very zoomed in/out
                    Rpx = Math.max(
                        Math.min(w, h) * 0.35,
                        Math.min(Rpx, Math.max(w, h) * 2.2),
                    );

                    const g = gctx.createRadialGradient(
                        coreX,
                        coreY,
                        0,
                        coreX,
                        coreY,
                        Rpx,
                    );
                    g.addColorStop(0.0, "rgba(80,160,255,0.10)");
                    g.addColorStop(0.22, "rgba(60,130,255,0.06)");
                    g.addColorStop(0.6, "rgba(40, 90,220,0.03)");
                    g.addColorStop(1.0, "rgba(0,0,0,0.00)");

                    gctx.save();
                    gctx.globalCompositeOperation = "screen";
                    gctx.fillStyle = g;
                    gctx.fillRect(0, 0, w, h);
                    gctx.restore();
                }

                const upp = galaxyUnitsPerPixel();
                const halfW = w * 0.5 * upp;
                const halfH = h * 0.5 * upp;

                const minX = gPanX - halfW,
                    maxX = gPanX + halfW;
                const minZ = gPanZ - halfH,
                    maxZ = gPanZ + halfH;

                // grid cells visible
                const ix0 = Math.floor(minX / CELL),
                    ix1 = Math.floor(maxX / CELL);
                const iz0 = Math.floor(minZ / CELL),
                    iz1 = Math.floor(maxZ / CELL);

                // draw stars (cap count for perf)
                gctx.save();
                gctx.globalCompositeOperation = "lighter";

                const MAX_DRAW = 30000; // full screen can handle more than mini-map
                let drawn = 0;

                for (let iz = iz0; iz <= iz1; iz++) {
                    for (let ix = ix0; ix <= ix1; ix++) {
                        const arr = gGrid.get(gKey(ix, iz));
                        if (!arr) continue;

                        for (let k = 0; k < arr.length; k++) {
                            const s = galaxyStars[arr[k]];
                            if (
                                s.x < minX ||
                                s.x > maxX ||
                                s.z < minZ ||
                                s.z > maxZ
                            )
                                continue;

                            const px = cx + (s.x - gPanX) / upp;
                            const py = cy + (s.z - gPanZ) / upp;

                            const base = 1.0 + (1.0 - s.mag) * 2.4;
                            const rad = Math.max(
                                0.6,
                                Math.min(
                                    3.4,
                                    base * (0.55 + 0.45 * Math.sqrt(gZoom)),
                                ),
                            );
                            const alpha = 0.1 + (1.0 - s.mag) * 0.7;

                            gctx.fillStyle = s.col + alpha.toFixed(3) + ")";
                            gctx.beginPath();
                            gctx.arc(px, py, rad, 0, Math.PI * 2);
                            gctx.fill();

                            if (++drawn >= MAX_DRAW) break;
                        }
                        if (drawn >= MAX_DRAW) break;
                    }
                    if (drawn >= MAX_DRAW) break;
                }

                gctx.restore();

                // galactic core (0,0)
                {
                    const gx = cx + (0 - gPanX) / upp;
                    const gy = cy + (0 - gPanZ) / upp;
                    gctx.fillStyle = "rgba(255,220,180,0.7)";
                    gctx.beginPath();
                    gctx.arc(gx, gy, 4.2, 0, Math.PI * 2);
                    gctx.fill();
                    gctx.strokeStyle = "rgba(255,220,180,0.25)";
                    gctx.beginPath();
                    gctx.arc(gx, gy, 22, 0, Math.PI * 2);
                    gctx.stroke();
                }

                // player marker (world XZ as proxy)
                {
                    const pxw = galaxyPlayer.x;
                    const pzw = galaxyPlayer.z;
                    const px = cx + (pxw - gPanX) / upp;
                    const py = cy + (pzw - gPanZ) / upp;

                    gctx.fillStyle = "rgba(120,220,255,0.95)";
                    gctx.beginPath();
                    gctx.arc(px, py, 4.0, 0, Math.PI * 2);
                    gctx.fill();
                    gctx.strokeStyle = "rgba(120,220,255,0.25)";
                    gctx.beginPath();
                    gctx.arc(px, py, 16.0, 0, Math.PI * 2);
                    gctx.stroke();
                }

                // selected star highlight
                if (gSelected >= 0) {
                    const s = galaxyStars[gSelected];
                    const sx = cx + (s.x - gPanX) / upp;
                    const sy = cy + (s.z - gPanZ) / upp;

                    gctx.strokeStyle = "rgba(255,255,255,0.85)";
                    gctx.lineWidth = 2;
                    gctx.beginPath();
                    gctx.arc(sx, sy, 18, 0, Math.PI * 2);
                    gctx.stroke();
                    gctx.lineWidth = 1;

                    gctx.fillStyle = "rgba(255,255,255,0.85)";
                    gctx.font =
                        "13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
                    gctx.fillText(`Selected: #${gSelected}`, sx + 22, sy + 4);
                }

                // corner stats
                gctx.fillStyle = "rgba(255,255,255,0.65)";
                gctx.font =
                    "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
                gctx.fillText(
                    `Stars: ${STAR_COUNT.toLocaleString()} | Zoom: ${gZoom.toFixed(2)}x`,
                    12,
                    h - 16,
                );
            }

            //

            //////////////////////////////////////////////////////////////////////////////
            // Galaxy map (2D overlay)
            ////////////////////////////////////////////////////////////////////////////////
            const mapCanvas = document.getElementById("galaxyMap");
            const mapCtx = mapCanvas.getContext("2d", { alpha: true });

            let galaxyMapOn = true;
            let galaxyMapZoom = 1.0;

            function resizeGalaxyMap() {
                const dpr = Math.max(1, devicePixelRatio || 1);
                const rect = mapCanvas.getBoundingClientRect();
                mapCanvas.width = Math.floor(rect.width * dpr);
                mapCanvas.height = Math.floor(rect.height * dpr);
                mapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            resizeGalaxyMap();

            addEventListener("keydown", (e) => {
                if (e.code === "KeyM") {
                    galaxyMapOn = !galaxyMapOn;
                    mapCanvas.classList.toggle("off", !galaxyMapOn);
                }
                if (e.code === "Equal")
                    galaxyMapZoom = Math.min(6.0, galaxyMapZoom * 1.12);
                if (e.code === "Minus")
                    galaxyMapZoom = Math.max(0.35, galaxyMapZoom / 1.12);
            });

            addEventListener("resize", resizeGalaxyMap);

            const _mapV = new THREE.Vector3();
            function hexToCss(hex) {
                const c = new THREE.Color(hex ?? 0xffffff);
                const r = (c.r * 255) | 0,
                    g = (c.g * 255) | 0,
                    b = (c.b * 255) | 0;
                return `rgb(${r},${g},${b})`;
            }

            function drawGalaxyMap() {
                if (!galaxyMapOn) return;

                const w = mapCanvas.getBoundingClientRect().width;
                const h = mapCanvas.getBoundingClientRect().height;
                const cx = w * 0.5,
                    cy = h * 0.5;
                const R = Math.min(w, h) * 0.46;

                let maxOrbit = 1;
                for (const b of bodies) {
                    const od = b?.cfg?.orbitDist ?? 0;
                    if (od > maxOrbit) maxOrbit = od;
                }
                maxOrbit = maxOrbit * 1.06 + 1200;
                const scale = (R / maxOrbit) * galaxyMapZoom;

                // Minimap follow + clamp to map bounds
                const clamp = (v, a, b) => Math.min(Math.max(v, a), b);

                // Desired center = player (fallback to camera)
                const desiredPanX = player?.worldPos?.x ?? camera.position.x;
                const desiredPanZ = player?.worldPos?.z ?? camera.position.z;

                // Visible radius in world units (the circle edge). At zoom=1 this == maxOrbit.
                const viewRadius = maxOrbit / galaxyMapZoom;

                // Clamp pan so the visible circle never goes past the map bounds.
                // If the view covers the whole map (zoom<=1), lock to center (0,0).
                const minPan = -maxOrbit + viewRadius;
                const maxPan = maxOrbit - viewRadius;

                let mapPanX = 0,
                    mapPanZ = 0;
                if (minPan < maxPan) {
                    mapPanX = clamp(desiredPanX, minPan, maxPan);
                    mapPanZ = clamp(desiredPanZ, minPan, maxPan);
                }

                // Screen-space position of world origin after panning
                const originX = cx - mapPanX * scale;
                const originY = cy - mapPanZ * scale;

                mapCtx.clearRect(0, 0, w, h);

                const g = mapCtx.createRadialGradient(
                    cx,
                    cy,
                    0,
                    cx,
                    cy,
                    R * 1.05,
                );
                g.addColorStop(0.0, "rgba(0,0,0,0.00)");
                g.addColorStop(1.0, "rgba(0,0,0,0.55)");
                mapCtx.fillStyle = "rgba(0,0,0,0.22)";
                mapCtx.fillRect(0, 0, w, h);
                mapCtx.fillStyle = g;
                mapCtx.fillRect(0, 0, w, h);

                // Clip orbit/range rings to the minimap circle
                // so zoom shows partial arcs instead of disappearing
                mapCtx.save();
                mapCtx.beginPath();
                mapCtx.arc(cx, cy, R, 0, Math.PI * 2);
                mapCtx.clip();

                mapCtx.save();
                mapCtx.translate(originX, originY);
                mapCtx.lineWidth = 1;
                mapCtx.strokeStyle = "rgba(255,255,255,0.07)";
                const step = 2000;
                const rings = Math.floor(maxOrbit / step);
                for (let i = 1; i <= rings; i++) {
                    const rr = i * step * scale;
                    mapCtx.beginPath();
                    mapCtx.arc(0, 0, rr, 0, Math.PI * 2);
                    mapCtx.stroke();
                }
                mapCtx.restore();

                mapCtx.save();
                mapCtx.translate(originX, originY);
                mapCtx.strokeStyle = "rgba(255,255,255,0.12)";
                for (const b of bodies) {
                    const od = b?.cfg?.orbitDist ?? 0;
                    if (od <= 0) continue;
                    const rr = od * scale;
                    mapCtx.beginPath();
                    mapCtx.arc(0, 0, rr, 0, Math.PI * 2);
                    mapCtx.stroke();
                }
                mapCtx.restore();

                mapCtx.save();
                mapCtx.translate(originX, originY);
                mapCtx.fillStyle = "rgba(255, 210, 140, 0.95)";
                mapCtx.beginPath();
                mapCtx.arc(0, 0, 4.5, 0, Math.PI * 2);
                mapCtx.fill();
                mapCtx.fillStyle = "rgba(255, 210, 140, 0.22)";
                mapCtx.beginPath();
                mapCtx.arc(0, 0, 16, 0, Math.PI * 2);
                mapCtx.fill();
                mapCtx.restore();

                // end orbit/ring clip
                mapCtx.restore();

                mapCtx.save();
                mapCtx.font =
                    "11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
                mapCtx.textBaseline = "middle";

                const nearInfo = nearestBodyInfo(camera.position);
                const nearestIndex = nearInfo?.i ?? -1;

                for (let i = 0; i < bodies.length; i++) {
                    const b = bodies[i];
                    b.group.getWorldPosition(_mapV);

                    const x = originX + _mapV.x * scale;
                    const y = originY + _mapV.z * scale;
                    if (x < -40 || x > w + 40 || y < -40 || y > h + 40)
                        continue;

                    const baseR = b?.cfg?.baseRadius ?? 1400;
                    const dot = THREE.MathUtils.clamp(
                        2.2 + (baseR / 1400) * 1.2,
                        2.0,
                        4.2,
                    );

                    const isHi = i === nearestIndex;
                    const name = b?.cfg?.name ?? `P${i + 1}`;

                    mapCtx.beginPath();
                    mapCtx.fillStyle = hexToCss(b?.cfg?.color ?? 0xffffff);
                    mapCtx.arc(x, y, dot + (isHi ? 1.6 : 0.0), 0, Math.PI * 2);
                    mapCtx.fill();

                    if (isHi) {
                        mapCtx.strokeStyle = "rgba(255,255,255,0.85)";
                        mapCtx.lineWidth = 1.5;
                        mapCtx.beginPath();
                        mapCtx.arc(x, y, dot + 4.2, 0, Math.PI * 2);
                        mapCtx.stroke();
                        mapCtx.lineWidth = 1;
                    }

                    mapCtx.fillStyle = "rgba(255,255,255,0.75)";
                    mapCtx.fillText(name, x + 8, y);
                }

                {
                    const px =
                        originX +
                        (player?.worldPos?.x ?? camera.position.x) * scale;
                    const py =
                        originY +
                        (player?.worldPos?.z ?? camera.position.z) * scale;

                    mapCtx.fillStyle = "rgba(120, 220, 255, 0.95)";
                    mapCtx.beginPath();
                    mapCtx.arc(px, py, 3.2, 0, Math.PI * 2);
                    mapCtx.fill();

                    mapCtx.strokeStyle = "rgba(120, 220, 255, 0.35)";
                    mapCtx.beginPath();
                    mapCtx.arc(px, py, 9.0, 0, Math.PI * 2);
                    mapCtx.stroke();
                }

                mapCtx.fillStyle = "rgba(255,255,255,0.65)";
                mapCtx.fillText(
                    `Map: M | Zoom: +/-  (${galaxyMapZoom.toFixed(2)}x)`,
                    12,
                    h - 14,
                );

                mapCtx.restore();
            }

            function makeRadialGlowTexture(size = 256) {
                const c = document.createElement("canvas");
                c.width = c.height = size;
                const ctx = c.getContext("2d");
                const g = ctx.createRadialGradient(
                    size * 0.5,
                    size * 0.5,
                    size * 0.0,
                    size * 0.5,
                    size * 0.5,
                    size * 0.5,
                );
                g.addColorStop(0.0, "rgba(255,255,255,1.00)");
                g.addColorStop(0.15, "rgba(255,235,200,0.85)");
                g.addColorStop(0.35, "rgba(255,190,120,0.35)");
                g.addColorStop(1.0, "rgba(0,0,0,0.00)");
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, size, size);
                const tex = new THREE.CanvasTexture(c);
                tex.colorSpace = THREE.SRGBColorSpace;
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.generateMipmaps = true;
                return tex;
            }

            // Sun + system root
            const system = new THREE.Group();
            scene.add(system);

            const SUN_RADIUS = 450;
            const sun = new THREE.Mesh(
                new THREE.SphereGeometry(SUN_RADIUS, 40, 20),
                new THREE.MeshStandardMaterial({
                    color: 0xffcc66,
                    emissive: 0xffaa33,
                    emissiveIntensity: 2.6,
                    roughness: 0.65,
                }),
            );
            system.add(sun);

            // Sun glow
            const sunGlowTex = makeRadialGlowTexture(256);
            const sunGlow = new THREE.Sprite(
                new THREE.SpriteMaterial({
                    map: sunGlowTex,
                    transparent: true,
                    depthWrite: false,
                    depthTest: true,
                    blending: THREE.AdditiveBlending,
                    opacity: 1.0,
                    color: 0xffcc88,
                }),
            );
            sunGlow.renderOrder = -10;
            sunGlow.scale.setScalar(SUN_RADIUS * 10.0);
            sun.add(sunGlow);

            const corona = new THREE.Mesh(
                new THREE.SphereGeometry(SUN_RADIUS * 1.12, 48, 24),
                new THREE.MeshBasicMaterial({
                    color: 0xffbb66,
                    transparent: true,
                    opacity: 0.18,
                    side: THREE.BackSide,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                }),
            );
            corona.renderOrder = -9;
            sun.add(corona);

            ////////////////////////////////////////////////////////////////////////////////
            // SUN LIGHT: SuperPointLight (PointLight + focused SpotLight shadows)
            // - PointLight: omnidirectional light + coarse point shadows
            // - Internal SpotLight: high-res shadows aimed at the player
            //   Spot cone auto-adjusts so its radius at the player is ~300 units (cap 89°).
            ////////////////////////////////////////////////////////////////////////////////

            // TODO: Clean this
            const SUN_LIGHT_INTENSITY = 18.0; // old "sun cube" total knob

            const sunLight = new SuperPointLight(
                0xffffff,
                SUN_LIGHT_INTENSITY / 6.0, // match old per-face energy feel
                260000,
                0.0,
                {
                    // point shadows (coarse)
                    pointCastShadow: true,
                    pointShadowMapSize: QUALITY_POINT_SHADOW,
                    pointShadowNear: 50,
                    pointShadowFar: 45000,
                    pointShadowBias: -0.00015,
                    pointShadowNormalBias: 0.18,

                    // spot shadows (sharp)
                    spotCastShadow: true,
                    spotShadowMapSize: QUALITY_SPOT_SHADOW,
                    spotShadowNear: 50,
                    spotShadowFar: 45000,
                    spotShadowBias: -0.00015,
                    spotShadowNormalBias: 0.18,
                    spotFocus: 1.0,
                    spotAngleDeg: 45, // overridden dynamically
                    spotPenumbra: 0.15,
                    spotIntensityFactor: 1.0,
                    spotDirection: new THREE.Vector3(0, 0, 1),
                },
            );
            system.add(sunLight);

            // Toggle with P
            const sunLightToggle = { on: true, saved: sunLight.intensity };
            addEventListener("keydown", (e) => {
                if (e.code !== "KeyP") return;
                if (sunLightToggle.on) {
                    sunLightToggle.saved = sunLight.intensity;
                    sunLight.intensity = 0;
                    sunLight.syncSpotIntensity();
                    sunLightToggle.on = false;
                } else {
                    sunLight.intensity = sunLightToggle.saved;
                    sunLight.syncSpotIntensity();
                    sunLightToggle.on = true;
                }
            });

            let _splAngle = null;
            function updateSunSuperPointLight(sunPosW, playerPosW, dt, tmp) {
                sunLight.position.copy(sunPosW);

                const spot = sunLight.shadowLight;

                // Aim spot at player (target is parented to sunLight => local-space target position)
                tmp.vA.copy(playerPosW);
                sunLight.worldToLocal(tmp.vA);
                spot.target.position.copy(tmp.vA);

                // Keep matrices current so shadow pass uses latest target/frustum
                sunLight.updateMatrixWorld(true);
                spot.updateMatrixWorld(true);
                spot.target.updateMatrixWorld(true);

                // Auto half-angle: radius = tan(angle) * distance => angle = atan(radius / distance)
                const d = Math.max(0.001, sunPosW.distanceTo(playerPosW));
                const desiredRadius = 300.0;
                const maxA = THREE.MathUtils.degToRad(89.0);
                const minA = THREE.MathUtils.degToRad(0.05);
                const targetA = THREE.MathUtils.clamp(
                    Math.atan(desiredRadius / d),
                    minA,
                    maxA,
                );

                // Smooth to avoid pops
                if (_splAngle === null) _splAngle = targetA;
                const alpha = 1.0 - Math.exp(-12.0 * Math.max(0.0, dt));
                _splAngle += (targetA - _splAngle) * alpha;

                if (Math.abs(spot.angle - _splAngle) > 1e-5) {
                    spot.angle = _splAngle;
                    spot.shadow.camera.near = 50.0;
                    spot.shadow.camera.far = 45000.0;
                    spot.shadow.camera.updateProjectionMatrix();
                }

                if (sunLight.castShadow) {
                    sunLight.shadow.camera.near = 50.0;
                    sunLight.shadow.camera.far = 45000.0;
                    sunLight.shadow.camera.updateProjectionMatrix();
                }
            }

            ////////////////////////////////////////////////////////////////////////////////
            // Fullscreen tri + RT (log depth) + copy pass
            ////////////////////////////////////////////////////////////////////////////////
            const fsTri = new THREE.BufferGeometry();
            fsTri.setAttribute(
                "position",
                new THREE.BufferAttribute(
                    new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                    3,
                ),
            );
            fsTri.setAttribute(
                "uv",
                new THREE.BufferAttribute(
                    new Float32Array([0, 0, 2, 0, 0, 2]),
                    2,
                ),
            );

            const screenCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            function makeRT(w, h) {
                const rtt = new THREE.WebGLRenderTarget(w, h, {
                    depthBuffer: true,
                    stencilBuffer: false,
                    type: THREE.HalfFloatType,
                    format: THREE.RGBAFormat,
                });

                rtt.texture.colorSpace = THREE.LinearSRGBColorSpace;
                rtt.texture.generateMipmaps = false;

                rtt.depthTexture = new THREE.DepthTexture(w, h);
                rtt.depthTexture.format = THREE.DepthFormat;
                rtt.depthTexture.type = THREE.UnsignedIntType;

                return rtt;
            }

            function makeColorRT(w, h) {
                const rtt = new THREE.WebGLRenderTarget(w, h, {
                    depthBuffer: false,
                    stencilBuffer: false,
                    type: THREE.HalfFloatType,
                    format: THREE.RGBAFormat,
                });

                rtt.texture.colorSpace = THREE.LinearSRGBColorSpace;
                rtt.texture.generateMipmaps = false;

                return rtt;
            }

            let rt = makeRT(innerWidth, innerHeight);
            let atmoRT = makeColorRT(
                Math.floor(innerWidth * QUALITY_ATMO_SCALE),
                Math.floor(innerHeight * QUALITY_ATMO_SCALE),
            );
            let cloudRT = makeColorRT(
                Math.floor(innerWidth * QUALITY_CLOUD_SCALE),
                Math.floor(innerHeight * QUALITY_CLOUD_SCALE),
            );
            cloudRT.texture.colorSpace = THREE.NoColorSpace;

            // rt -> screen copy
            const copyScene = new THREE.Scene();
            const copyMat = new THREE.ShaderMaterial({
                depthTest: false,
                depthWrite: false,
                toneMapped: false,
                uniforms: {
                    tColor: { value: rt.texture },
                    uExposure: { value: 0.25 },
                },
                vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`,
                fragmentShader: `
precision highp float;
uniform sampler2D tColor;
uniform float uExposure;
varying vec2 vUv;

vec3 acesToneMap(vec3 x){
  x *= uExposure;
  return clamp((x * (2.51*x + 0.03)) / (x * (2.43*x + 0.59) + 0.14), 0.0, 1.0);
}

void main(){
  vec3 col = texture2D(tColor, clamp(vUv,0.0,1.0)).rgb; // linear
  col = acesToneMap(col);
  gl_FragColor = linearToOutputTexel(vec4(col, 1.0));
}
`,
            });
            const copyMesh = new THREE.Mesh(fsTri, copyMat);
            copyMesh.frustumCulled = false;
            copyScene.add(copyMesh);

            // atmo overlay blit
            const atmoCopyScene = new THREE.Scene();
            const atmoCopyMat = new THREE.ShaderMaterial({
                transparent: true,
                depthTest: false,
                depthWrite: false,
                blending: THREE.NormalBlending,
                toneMapped: false,
                uniforms: {
                    tAtmo: { value: atmoRT.texture },
                    uExposure: { value: 0.25 },
                },
                vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`,
                fragmentShader: `
precision highp float;
varying vec2 vUv;
uniform sampler2D tAtmo;
uniform float uExposure;

vec3 acesToneMap(vec3 x){
  x *= uExposure;
  return clamp((x * (2.51*x + 0.03)) / (x * (2.43*x + 0.59) + 0.14), 0.0, 1.0);
}

void main(){
  vec4 c = texture2D(tAtmo, clamp(vUv,0.0,1.0));
  c.rgb = acesToneMap(c.rgb);
  gl_FragColor = linearToOutputTexel(c);
}
`,
            });
            const atmoCopyMesh = new THREE.Mesh(fsTri, atmoCopyMat);
            atmoCopyMesh.frustumCulled = false;
            atmoCopyScene.add(atmoCopyMesh);

            ////////////////////////////////////////////////////////////////////////////////
            // Galaxy sky dome (procedural)
            ////////////////////////////////////////////////////////////////////////////////
            function makeGalaxySkyDome(THREE) {
                const geo = new THREE.SphereGeometry(9000, 64, 32);
                const mat = new THREE.ShaderMaterial({
                    side: THREE.BackSide,
                    depthTest: true,
                    depthWrite: false,
                    uniforms: {
                        uTime: { value: 0.0 },
                        uBrightness: { value: 1.1 },
                        uStarDensity: { value: 1.2 },
                        uGalaxyStrength: { value: 1.15 },
                        uBandStrength: { value: 1.35 },
                        uBandTilt: { value: 0.45 },
                    },
                    vertexShader: `
varying vec3 vDirW;
void main() {
  vec4 wp = modelMatrix * vec4(position, 1.0);
  vDirW = normalize(wp.xyz - cameraPosition);
  gl_Position = projectionMatrix * viewMatrix * wp;
}`,
                    fragmentShader: `
precision highp float;
varying vec3 vDirW;

uniform float uTime;
uniform float uBrightness;
uniform float uStarDensity;
uniform float uGalaxyStrength;
uniform float uBandStrength;
uniform float uBandTilt;

float hash(vec3 p){
  p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
  p *= 17.0;
  return fract(p.x*p.y*p.z*(p.x+p.y*p.z));
}
float noise(vec3 p){
  vec3 i = floor(p);
  vec3 f = fract(p);
  f = f*f*(3.0-2.0*f);

  float n000 = hash(i+vec3(0,0,0));
  float n100 = hash(i+vec3(1,0,0));
  float n010 = hash(i+vec3(0,1,0));
  float n110 = hash(i+vec3(1,1,0));
  float n001 = hash(i+vec3(0,0,1));
  float n101 = hash(i+vec3(1,0,1));
  float n011 = hash(i+vec3(0,1,1));
  float n111 = hash(i+vec3(1,1,1));

  float x00 = mix(n000,n100,f.x);
  float x10 = mix(n010,n110,f.x);
  float x01 = mix(n001,n101,f.x);
  float x11 = mix(n011,n111,f.x);

  float y0 = mix(x00,x10,f.y);
  float y1 = mix(x01,x11,f.y);
  return mix(y0,y1,f.z);
}
float fbm(vec3 p){
  float s=0.0, a=0.5;
  for(int i=0;i<5;i++){
    s += a*noise(p);
    p *= 2.02;
    a *= 0.5;
  }
  return s;
}
vec3 rotX(vec3 v, float a){
  float s=sin(a), c=cos(a);
  return vec3(v.x, c*v.y - s*v.z, s*v.y + c*v.z);
}

void main() {
  vec3 d = normalize(vDirW);
  vec3 p = d * 180.0;

  float n  = noise(p * 2.3 + 19.0);
  float n2 = noise(p * 5.7 + 71.0);

  float stars = smoothstep(0.985, 1.0, n) * 1.2;
  stars += smoothstep(0.992, 1.0, n2) * 0.9;
  stars *= uStarDensity;

  float tw = 0.75 + 0.25*sin(uTime*2.0 + hash(p)*6.2831);
  stars *= tw;

  float tint = hash(p + 3.1);
  vec3 starCol = mix(vec3(0.75,0.85,1.0), vec3(1.0,0.9,0.8), tint);

  vec3 bt = rotX(d, uBandTilt);
  float band = 1.0 - abs(bt.y);
  band = pow(band, 6.0);
  float dust = fbm(bt*8.0 + vec3(0.0, uTime*0.01, 0.0));
  float bandMask = band * (0.45 + 0.75*dust);
  bandMask *= uBandStrength;

  float g1 = fbm(d*3.0 + vec3(20.0,0.0,0.0));
  float g2 = fbm(d*6.0 + vec3(-7.0,11.0,0.0));
  float gal = smoothstep(0.62, 0.95, g1) * 0.6 + smoothstep(0.68, 0.98, g2) * 0.45;
  gal *= uGalaxyStrength;

  vec3 bandCol = vec3(0.65, 0.75, 1.0);
  vec3 nebCol  = vec3(0.85, 0.55, 1.0);

  vec3 col = vec3(0.0);
  col += starCol * stars * 1.25;
  col += bandCol * bandMask * 0.45;
  col += nebCol * gal * 0.20;
  col += vec3(0.01, 0.012, 0.02);

  float vign = 0.75 + 0.25 * (d.y*0.5 + 0.5);
  col *= vign;

  col *= uBrightness;
  gl_FragColor = vec4(col, 1.0);
}`,
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.frustumCulled = false;
                mesh.renderOrder = -9999;
                return mesh;
            }
            const sky = makeGalaxySkyDome(THREE);
            scene.add(sky);

            ////////////////////////////////////////////////////////////////////////////////
            // Blue-noise texture + fallback
            ////////////////////////////////////////////////////////////////////////////////
            function makeFallbackNoiseTexture(size = 256) {
                const data = new Uint8Array(size * size * 4);
                for (let i = 0; i < size * size; i++) {
                    const v = (Math.random() * 256) | 0;
                    data[i * 4 + 0] = v;
                    data[i * 4 + 1] = v;
                    data[i * 4 + 2] = v;
                    data[i * 4 + 3] = 255;
                }
                const tex = new THREE.DataTexture(
                    data,
                    size,
                    size,
                    THREE.RGBAFormat,
                );
                tex.needsUpdate = true;
                tex.colorSpace = THREE.NoColorSpace;
                tex.minFilter = THREE.NearestFilter;
                tex.magFilter = THREE.NearestFilter;
                tex.wrapS = THREE.RepeatWrapping;
                tex.wrapT = THREE.RepeatWrapping;
                tex.generateMipmaps = false;
                tex.flipY = false;
                return tex;
            }
            let blueNoiseTex = makeFallbackNoiseTexture(256);
            let blueNoiseReady = false;
            const BLUE_NOISE_URL =
                "https://raw.githubusercontent.com/Calinou/free-blue-noise-textures/master/256_256/HDR_RGBA_0.png";
            new THREE.TextureLoader().load(
                BLUE_NOISE_URL,
                (t) => {
                    t.colorSpace = THREE.NoColorSpace;
                    t.minFilter = THREE.NearestFilter;
                    t.magFilter = THREE.NearestFilter;
                    t.wrapS = THREE.RepeatWrapping;
                    t.wrapT = THREE.RepeatWrapping;
                    t.generateMipmaps = false;
                    t.flipY = false;
                    blueNoiseTex.dispose();
                    blueNoiseTex = t;
                    blueNoiseReady = true;
                },
                undefined,
                () => {
                    blueNoiseReady = true;
                },
            );

            ////////////////////////////////////////////////////////////////////////////////
            // Underwater post overlays
            ////////////////////////////////////////////////////////////////////////////////
            const postScene = new THREE.Scene();
            const tintMat = new THREE.ShaderMaterial({
                transparent: true,
                depthTest: false,
                depthWrite: false,
                uniforms: {
                    uColor: { value: new THREE.Color(0x06131f) },
                    uOpacity: { value: 0.0 },
                },
                vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0);} `,
                fragmentShader: `precision highp float; varying vec2 vUv; uniform vec3 uColor; uniform float uOpacity;
void main(){ gl_FragColor = vec4(uColor, uOpacity); }`,
            });
            const tintMesh = new THREE.Mesh(fsTri, tintMat);
            tintMesh.frustumCulled = false;
            postScene.add(tintMesh);

            const particlesMat = new THREE.ShaderMaterial({
                transparent: true,
                depthTest: false,
                depthWrite: false,
                uniforms: {
                    uColor: { value: new THREE.Color(0x0a2430) },
                    uOpacity: { value: 0.0 },
                    uTime: { value: 0.0 },
                    uNoiseTex: { value: blueNoiseTex },
                    uNoiseSize: { value: new THREE.Vector2(256, 256) },
                },
                vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0);} `,
                fragmentShader: `
precision highp float;
varying vec2 vUv;
uniform vec3 uColor;
uniform float uOpacity;
uniform float uTime;
uniform sampler2D uNoiseTex;
uniform vec2 uNoiseSize;
void main(){
  vec2 tile = max(uNoiseSize, vec2(1.0));
  vec2 uvn = fract((gl_FragCoord.xy + vec2(uTime*60.0, uTime*35.0)) / tile);
  float n = texture2D(uNoiseTex, uvn).r;
  float speck = smoothstep(0.78, 0.95, n) * (0.65 + 0.35*sin(uTime*1.7));
  float v = speck * uOpacity;
  gl_FragColor = vec4(uColor * (0.55 + 0.45*n), v);
}`,
            });
            const particlesMesh = new THREE.Mesh(fsTri, particlesMat);
            particlesMesh.frustumCulled = false;
            postScene.add(particlesMesh);

            ////////////////////////////////////////////////////////////////////////////////
            // God Rays pass (cloud-occluded)
            ////////////////////////////////////////////////////////////////////////////////
            const godRayScene = new THREE.Scene();
            const godRayMat = new THREE.ShaderMaterial({
                transparent: true,
                depthTest: false,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                uniforms: {
                    tDepth: { value: rt.depthTexture },
                    tCloud: { value: cloudRT.texture },
                    uSunScreen: { value: new THREE.Vector2(0.5, 0.5) },
                    uLightColor: { value: new THREE.Color(1.0, 0.95, 0.85) },
                    uIntensity: { value: 0.0 }, // start off, we compute per frame
                    uWeight: { value: 0.18 },
                    uSamples: { value: QUALITY_GODRAY_SAMPLES },
                    uDecay: { value: 0.92 },
                    uDensity: { value: 0.7 },
                },
                vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position = vec4(position,1.0); }`,
                fragmentShader: `
precision highp float;
varying vec2 vUv;
uniform sampler2D tDepth;
uniform sampler2D tCloud;
uniform vec2 uSunScreen;
uniform vec3 uLightColor;
uniform float uIntensity;
uniform float uDecay;
uniform float uDensity;
uniform float uWeight;
uniform float uSamples;

float depthAt(vec2 uv){ return texture2D(tDepth, uv).r; }
float cloudAt(vec2 uv){ return texture2D(tCloud, uv).r; }

void main(){
  vec2 uv = vUv;
  vec2 s = uSunScreen;
  float onScreen =
    step(0.0, s.x) * step(0.0, s.y) * step(s.x, 1.0) * step(s.y, 1.0);

  vec2 delta = (s - uv) * (uDensity / max(uSamples, 1.0));

  float illum = 0.0;
  float decay = 1.0;

  for(float i=0.0; i<128.0; i++){
    if(i >= uSamples) break;
    uv += delta;

    float d = depthAt(uv);
    float occluded = step(d, 0.99999);

    float cloud = cloudAt(uv);
    float trans = 1.0 - cloud;

    illum += (1.0 - occluded) * trans * decay * uWeight;
    decay *= uDecay;
  }

  vec3 col = illum * uLightColor * uIntensity * onScreen;
  gl_FragColor = vec4(col, illum * onScreen);
}`,
            });
            const godRayMesh = new THREE.Mesh(fsTri, godRayMat);
            godRayMesh.frustumCulled = false;
            godRayScene.add(godRayMesh);

            ////////////////////////////////////////////////////////////////////////////////
            // Create planets
            ////////////////////////////////////////////////////////////////////////////////
            function mulberry32(a) {
                return function () {
                    a |= 0;
                    a = (a + 0x6d2b79f5) | 0;
                    let t = Math.imul(a ^ (a >>> 15), 1 | a);
                    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
                    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                };
            }

            function seededHsl(seed, s, l) {
                const r = mulberry32(seed);
                const h = r();
                return new THREE.Color().setHSL(h, s, l).getHex();
            }

            const bodies = [];

            function makeColor(seed) {
                const r = ((seed * 16807) % 255) / 255;
                const g = ((seed * 48271) % 255) / 255;
                const b = ((seed * 69621) % 255) / 255;
                return new THREE.Color()
                    .setRGB(0.35 + 0.55 * r, 0.35 + 0.55 * g, 0.35 + 0.55 * b)
                    .getHex();
            }

            function addPlanet(cfg) {
                const p = new QuadSphereBody(cfg);
                system.add(p.group);
                p.index = bodies.length;
                bodies.push(p);
                return p;
            }

            ////////////////////////////////////////////////////////////////////////////////
            // MOONS: mini-planets (generated terrain + player latch) BUT no atmospheres, no oceans
            ////////////////////////////////////////////////////////////////////////////////

            const moons = [];

            function addMoonForPlanet(parentIndex, cfg = {}) {
                const parent = bodies[parentIndex];
                if (!parent) return null;

                const parentR =
                    parent.baseRadius ?? parent.cfg?.baseRadius ?? 1400;

                const radius =
                    cfg.radius ?? parentR * (0.12 + 0.1 * Math.random());
                const orbitDist =
                    cfg.orbitDist ??
                    parentR * (1.8 + 2.8 * Math.random()) + radius * 3.0;
                const orbitSpeed = cfg.orbitSpeed ?? 0.22 / orbitDist;
                const phase = cfg.phase ?? Math.random() * Math.PI * 2;

                const seedBase = (parent.cfg?.seed ?? 101010) | 0;
                const seed =
                    ((seedBase ^
                        ((radius * 1000) | 0) ^
                        ((orbitDist * 10) | 0)) >>>
                        0) |
                    0;

                const moonCfg = {
                    name: cfg.name ?? "MOON",
                    seed,
                    baseRadius: radius,

                    // terrain
                    heightAmp: cfg.heightAmp ?? Math.max(8.0, radius * 0.1),
                    heightFreq: cfg.heightFreq ?? 2.0 + 2.0 * Math.random(),
                    color: cfg.color ?? 0xb9b9b9,

                    // IMPORTANT: moons have NO ocean and NO atmo
                    hasOcean: false,
                    hasAtmo: false,
                    seaLevelOffset: -1e9,

                    // LOD tuning for small bodies
                    patchGridN: cfg.patchGridN ?? 10,
                    maxLevel: cfg.maxLevel ?? 7,
                    splitBudgetPerFrame: cfg.splitBudgetPerFrame ?? 4,
                    mergeBudgetPerFrame: cfg.mergeBudgetPerFrame ?? 4,
                    baseSplitFactor: cfg.baseSplitFactor ?? 9.2,
                    baseMergeFactor: cfg.baseMergeFactor ?? 14.2,
                    farDetail: cfg.farDetail ?? 2,
                    activeDist: cfg.activeDist ?? radius * 30.0,
                    lodDist: cfg.lodDist ?? radius * 22.0,
                    nodeCullFactor: cfg.nodeCullFactor ?? 2.2,

                    // orbit around the parent (we parent the group to the planet group)
                    orbitDist,
                    orbitSpeed,
                    phase,
                    // force a rocky/gray palette
                    grass: 0x6a6a6a, // was green
                    sand: 0x707070,
                    rock: 0x5a5a5a,
                    snow: 0x9a9a9a,

                    rockStart: 0.0,
                    rockSpan: 1e9,
                };

                const moon = new QuadSphereBody(moonCfg);

                // Parent under the planet so orbit is local to the planet
                parent.group.add(moon.group);

                moon.index = bodies.length;
                bodies.push(moon);
                moons.push(moon);

                return moon;
            }

            // Moons are updated via the same bodies loop
            function updateMoons(dt) {}

            const baseOrbit = 6800;
            const orbitStep = 3600;

            let currentSystemSeed = 101010;

            function clearCurrentSystem() {
                // moons first (they're parented to planets)
                for (const m of moons) {
                    if (m.group?.parent) m.group.parent.remove(m.group);
                    m.group?.traverse?.((obj) => {
                        if (obj.geometry) obj.geometry.dispose?.();
                        if (obj.material) {
                            if (Array.isArray(obj.material))
                                obj.material.forEach((mm) => mm.dispose?.());
                            else obj.material.dispose?.();
                        }
                    });
                }
                moons.length = 0;

                // atmosphere passes
                if (atmoPasses && atmoPasses.length) {
                    for (const p of atmoPasses) {
                        atmoScene.remove(p.atmoMesh);
                        atmoScene.remove(p.maskMesh);
                        p.atmoMesh?.material?.dispose?.();
                        p.maskMesh?.material?.dispose?.();
                    }
                }
                atmoPasses = [];

                // planets
                for (const b of bodies) {
                    system.remove(b.group);
                    b.destroy?.();
                }
                bodies.length = 0;
                clearSPLMaterialRegistry();
            }

            function buildSystemFromSeed(baseSeed) {
                currentSystemSeed = (baseSeed ?? 101010) >>> 0;

                // Sun tint variation (subtle)
                {
                    const tint = seededHsl(
                        currentSystemSeed ^ 0x5a17c3,
                        0.55,
                        0.62,
                    );
                    sun.material.color.setHex(tint);
                    sun.material.emissive.setHex(tint);
                    sun.material.emissiveIntensity =
                        2.2 + ((currentSystemSeed & 255) / 255) * 1.2;
                }

                // Planets
                const planetCount = 8;
                for (let i = 0; i < planetCount; i++) {
                    const seed = (currentSystemSeed + i * 99991) >>> 0;
                    const baseRadius = 1100 + ((seed >> 4) % 900);
                    const heightAmp = 120 + ((seed >> 9) % 150);
                    const heightFreq = 1.6 + (((seed >> 5) % 100) / 100) * 1.2;
                    const color = makeColor(seed);
                    const oceanColor = makeColor(seed ^ 0xabcdef);

                    const atmoTint = seededHsl(seed ^ 0x13579b, 0.7, 0.55);
                    const cloudTint = seededHsl(seed ^ 0x2468ac, 0.25, 0.92);

                    addPlanet({
                        name: `PLANET-${String(i + 1).padStart(2, "0")}`,
                        seed,
                        baseRadius,
                        heightAmp,
                        heightFreq,
                        color,
                        oceanColor,
                        oceanMurk: 0.62,
                        waveAmp: 2.8,
                        waveFreq: 0.013,
                        waveSpeed: 0.62,
                        seaLevelOffset: 0,
                        seabedDepth: heightAmp * 0.2,
                        shoreWidth: 24,
                        snowHeight: heightAmp * 0.62,
                        snowLat: 0.52,
                        deepWater: 0x061a2a,
                        shallowWater: 0x1f5568,
                        sand: 0xd9c38a,
                        grass: 0x2f6b34,
                        rock: 0x666666,
                        snow: 0xf7fbff,
                        orbitDist:
                            baseOrbit + i * orbitStep + ((seed % 500) - 250),
                        orbitSpeed:
                            0.004 + 1.0 / ((baseOrbit + i * orbitStep) * 1.8),
                        patchGridN: 10,
                        maxLevel: 8,
                        splitBudgetPerFrame: 6,
                        mergeBudgetPerFrame: 6,
                        baseSplitFactor: 9.2,
                        baseMergeFactor: 14.2,
                        farDetail: 2,
                        activeDist: baseRadius * 26.0,
                        lodDist: baseRadius * 18.0,
                        nodeCullFactor: 2.2,
                        atmoTint,
                        cloudTint,
                    });
                }

                // Moons
                const planetBodyCount = bodies.length; // snapshot before adding moons (moons push into bodies)
                for (let i = 0; i < planetBodyCount; i++) {
                    const p = bodies[i];
                    const R = p.cfg.baseRadius ?? 1400;
                    const count = 1 + ((p.cfg.seed ?? 1) % 3); // 1..3

                    for (let k = 0; k < count; k++) {
                        addMoonForPlanet(i, {
                            radius: R * (0.1 + 0.04 * k),
                            orbitDist: R * (2.8 + 0.9 * k) + 350,
                            orbitSpeed:
                                (0.35 + 0.12 * k) / (R * (2.8 + 0.9 * k) + 350),
                            color: k % 2 === 0 ? 0xbdbdbd : 0x8f8f8f,
                            phase: (k / Math.max(1, count)) * Math.PI * 2,
                        });
                    }
                }

                // Patch lit materials so the PointLight doesn't double-light inside the sun spot cone
                clearSPLMaterialRegistry();
                registerSPLMaterialsIn(system, sunLight);
            }

            function placePlayerNearNewStar(target) {
                // keep flying (warp already requires fly mode)
                player.mode = "fly";
                player.followIndex = -1;
                player.worldVel.set(0, 0, 0);

                // deterministic spawn direction from seed
                const rnd = mulberry32(
                    ((target?.seed ?? 101010) >>> 0) ^ 0x9e3779b9,
                );
                const a = rnd() * Math.PI * 2;
                const y = 0.1 + rnd() * 0.2;

                const sunW = sun.getWorldPosition(tmp.vA.set(0, 0, 0));
                const spawnDir = tmp.vB
                    .set(Math.cos(a), y, Math.sin(a))
                    .normalize();

                // place inside first orbit but safely away from the sun mesh
                const dist = Math.max(SUN_RADIUS * 7.0, 3200);
                player.worldPos.copy(sunW).addScaledVector(spawnDir, dist);

                // Preserve view angle to avoid any post-warp camera snap.
                camera.position.copy(player.worldPos);
                camera.quaternion.copy(flyQuat);
                camera.updateMatrixWorld(true);
            }

            function rebuildSystemForWarp(targetDesc) {
                clearCurrentSystem();
                buildSystemFromSeed((targetDesc?.seed ?? 101010) >>> 0);
                // Rebuild atmospheres now that we're in the new system
                atmoPasses = bodies
                    .filter((b) => b.hasAtmo !== false)
                    .map(makeAtmoPassForBody);
                applyQualityToAtmoPasses();

                // Update galaxy-location (marker in fullscreen galaxy map)
                if (targetDesc) {
                    if (typeof targetDesc.gx === "number")
                        galaxyPlayer.x = targetDesc.gx;
                    if (typeof targetDesc.gz === "number")
                        galaxyPlayer.z = targetDesc.gz;
                    if (targetDesc.name) galaxyPlayer.name = targetDesc.name;
                }

                // Spawn close to the star
                placePlayerNearNewStar(targetDesc);
            }

            // initial system
            buildSystemFromSeed(101010);

            ////////////////////////////////////////////////////////////////////////////////
            // Atmosphere + Clouds overlay (atmoRT) + cloud mask (cloudRT)
            // (atmoRT) + cloud mask (cloudRT)
            ////////////////////////////////////////////////////////////////////////////////
            const atmoScene = new THREE.Scene();
            const atmoVS = `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`;

            // Oh boy...
            // TODO: Performance, performance, did I say performance?
            const atmoFS = `
            precision highp float;
            varying vec2 vUv;

            uniform mat4 uInvViewMatrix;
            uniform mat4 uInvProjMatrix;

            uniform sampler2D uDepthTex;
            uniform float uLogDepthFC;

            uniform vec3  uPlanetCenterW;
            uniform float uPlanetRadius;
            uniform float uAtmoHeight;
            uniform vec3  uSunPosW;

            uniform sampler2D uBlueNoiseTex;
            uniform vec2      uBlueNoiseSize;

            uniform float uAtmoSteps;
            uniform float uAtmoDensity;
            uniform float uAtmoScaleHeight;
            uniform float uBlueStrength;
            uniform float uSunsetStrength;
            uniform float uNightDarken;
            uniform float uSunGlare;
            uniform float uMinLight;
            uniform float uDayOpacityBoost;

            uniform float uCloudBase;
            uniform float uCloudThickness;
            uniform float uCloudSteps;
            uniform float uCloudDensity;
            uniform float uCloudCoverage;
            uniform float uCloudSoftness;
            uniform float uCloudFreq;
            uniform float uCloudDetailFreq;
            uniform float uCloudWindSpeed;
            uniform float uCloudLightSteps;
            uniform float uCloudShadowStrength;
            uniform float uCloudPhase;

            uniform float uUseCheapClouds;
            uniform float uCheapCloudAlpha;
            uniform float uCheapCloudScale;
            uniform float uCheapCloudSharp;
            uniform float uCheapCloudRim;
            uniform float uCheapCloudFarBoost;
            uniform float uCheapCloudContrast;

            uniform vec3 uAtmoTint;
            uniform vec3 uCloudTint;

            uniform int   uOccCount;
            uniform vec3  uOccCenters[24];
            uniform float uOccRadii[24];
            uniform float uEclipseSoftness;
            uniform float uEclipseStrength;

            uniform float uTime;

            float saturate(float x){ return clamp(x, 0.0, 1.0); }

            float raySphereHit(vec3 ro, vec3 rd, vec3 c, float r){
              vec3 oc = ro - c;
              float b = dot(oc, rd);
              float c0 = dot(oc, oc) - r*r;
              float h = b*b - c0;
              if(h < 0.0) return 1e9;
              h = sqrt(h);
              float t0 = -b - h;
              float t1 = -b + h;
              if(t0 > 0.0) return t0;
              if(t1 > 0.0) return t1;
              return 1e9;
            }

            float sunVisibility(vec3 pW, vec3 sunPosW){
              vec3 rd = normalize(sunPosW - pW);
              float maxT = length(sunPosW - pW);

              float vis = 1.0;

              for(int i=0; i<24; i++){
                if(i >= uOccCount) break;
                float tHit = raySphereHit(pW, rd, uOccCenters[i], uOccRadii[i]);
                if(tHit < maxT){
                  vec3 oc = pW - uOccCenters[i];
                  float b = dot(oc, rd);
                  float d2 = dot(oc, oc) - b*b;
                  float d = sqrt(max(d2, 0.0));
                  float r = uOccRadii[i];

                  float edge = smoothstep(r, r + r*uEclipseSoftness, d);
                  vis = min(vis, edge);
                }
              }

              return mix(1.0, vis, clamp(uEclipseStrength, 0.0, 1.0));
            }

            vec2 raySphere(vec3 ro, vec3 rd, vec3 c, float r){
              vec3 oc = ro - c;
              float b = dot(oc, rd);
              float c0 = dot(oc, oc) - r*r;
              float h = b*b - c0;
              if(h < 0.0) return vec2(1e9, -1e9);
              h = sqrt(h);
              return vec2(-b - h, -b + h);
            }

            float sceneDistanceFromLogDepth(vec2 uv, vec3 rdV){
              float d = texture2D(uDepthTex, uv).r;
              if(d >= 0.999999) return 1e9;

              float log2_v = (d * 2.0) / max(uLogDepthFC, 1e-8);
              float vFragDepth = exp2(log2_v);
              float viewZ = -(vFragDepth - 1.0);
              float t = viewZ / rdV.z;
              if(!(t > 0.0)) return 1e9;
              return t;
            }

            float blueJitter(){
              vec2 pix = gl_FragCoord.xy;
              vec2 tile = max(uBlueNoiseSize, vec2(1.0));
              vec2 uvn = fract(pix / tile);
              float n = texture2D(uBlueNoiseTex, uvn).r;
              return n - 0.5;
            }

            float hash13(vec3 p){
              p = fract(p * 0.1031);
              p += dot(p, p.yzx + 33.33);
              return fract((p.x + p.y) * p.z);
            }

            float valueNoise(vec3 p){
              vec3 i = floor(p);
              vec3 f = fract(p);
              f = f*f*(3.0 - 2.0*f);

              float n000 = hash13(i + vec3(0,0,0));
              float n100 = hash13(i + vec3(1,0,0));
              float n010 = hash13(i + vec3(0,1,0));
              float n110 = hash13(i + vec3(1,1,0));
              float n001 = hash13(i + vec3(0,0,1));
              float n101 = hash13(i + vec3(1,0,1));
              float n011 = hash13(i + vec3(0,1,1));
              float n111 = hash13(i + vec3(1,1,1));

              float x00 = mix(n000, n100, f.x);
              float x10 = mix(n010, n110, f.x);
              float x01 = mix(n001, n101, f.x);
              float x11 = mix(n011, n111, f.x);
              float y0 = mix(x00, x10, f.y);
              float y1 = mix(x01, x11, f.y);
              return mix(y0, y1, f.z);
            }

            float fbm(vec3 p){
              float a = 0.5;
              float s = 0.0;
              float f = 1.0;
              for(int i=0;i<5;i++){
                s += a * valueNoise(p * f);
                f *= 2.02;
                a *= 0.5;
              }
              return s;
            }

            float phaseHG(float mu, float g){
              float gg = g*g;
              return (1.0 - gg) / pow(1.0 + gg - 2.0*g*mu, 1.5);
            }

            float cloudField(vec3 pW){
              vec3 lp = pW - uPlanetCenterW;
              float r = length(lp);
              vec3 dir = lp / max(r, 1e-6);

              float t = uTime * uCloudWindSpeed;

              float cs = cos(t), sn = sin(t);
              vec3 d2 = vec3(dir.x*cs - dir.z*sn, dir.y, dir.x*sn + dir.z*cs);

              float cloudBaseR = uPlanetRadius + uCloudBase;
              float h01 = saturate((r - cloudBaseR) / max(uCloudThickness, 1e-4));

              vec3 flow1 = vec3(0.37, 0.00, 0.29) * t;
              vec3 flow2 = vec3(-0.21, 0.00, 0.41) * (t * 1.35);

              vec3 heightWarp = vec3(0.0, (h01 - 0.5) * 0.35, 0.0);

              vec3 qBase   = d2 * uCloudFreq       + flow1 + heightWarp;
              vec3 qDetail = d2 * uCloudDetailFreq + flow2 + heightWarp * 1.7;

              float n = fbm(qBase);
              float d = n - uCloudCoverage;
              float base = saturate(d / max(uCloudSoftness, 1e-4));

              float nd = fbm(qDetail + vec3(17.3, 9.1, 33.7));
              float detail = mix(0.65, 1.15, nd);

              float profile =
                smoothstep(0.0, 0.15, h01) *
                (1.0 - smoothstep(0.65, 1.0, h01));

              return saturate(base * detail * profile);
            }

            void marchCloudSegment(
              in vec3 roW, in vec3 rdW,
              in float s0, in float s1,
              in float sceneT,
              in float jitter,
              in vec3 sunDir,
              in float phase,
              inout vec3 cloudCol,
              inout float cloudAlpha
            ){
              if(s0 > sceneT) return;
              s1 = min(s1, sceneT);
              if(s1 <= s0) return;

              float stepsC = max(8.0, uCloudSteps);
              float dtC = (s1 - s0) / stepsC;
              float j = jitter;

              for(float i=0.0; i<256.0; i+=1.0){
                if(i >= stepsC) break;

                float t = s0 + (i + 0.5 + j) * dtC;
                vec3 p = roW + rdW * t;

                vec3 upP = normalize(p - uPlanetCenterW);
                float dayP = saturate(dot(upP, sunDir) * 0.5 + 0.5);
                float nightMask = mix(uMinLight, 1.0, pow(dayP, uNightDarken));

                float vis = sunVisibility(p, uSunPosW);
                nightMask *= mix(1.0, vis, 1.0);

                float dens = cloudField(p) * uCloudDensity;
                if(dens <= 0.0005) continue;

                float sSteps = max(2.0, uCloudLightSteps);
                float sdt = (uCloudThickness * 1.2) / sSteps;

                float stau = 0.0;
                for(float k=0.0; k<64.0; k+=1.0){
                  if(k >= sSteps) break;
                  float st = (k + 1.0 + j) * sdt;
                  vec3 sp = p + sunDir * st;
                  float sd = cloudField(sp) * uCloudDensity;
                  stau += sd * sdt;
                  if(stau > 6.0) break;
                }
                float shadow = exp(-stau * uCloudShadowStrength);

                float aStep = 1.0 - exp(-dens * dtC);
                float contrib = (1.0 - cloudAlpha) * aStep;

                vec3 lit = vec3(1.0) * shadow;
                lit *= (0.55 + 0.45 * phase);

                float mu = dot(rdW, sunDir);
                lit *= mix(vec3(0.92, 0.96, 1.0), vec3(1.0, 0.92, 0.80), saturate(mu*0.5+0.5));

                lit *= nightMask;

                cloudCol += contrib * lit;
                cloudAlpha += contrib;

                if(cloudAlpha > 0.98) break;
              }
            }

            vec3 cheapClouds(
              vec3 roW, vec3 rdW,
              vec2 tOuter, vec2 tInner,
              float sceneT,
              float jitter,
              vec3 sunDir,
              out float outA
            ){
              outA = 0.0;

              float outerEnter = max(tOuter.x, 0.0);
              float outerExit  = max(tOuter.y, 0.0);
              if(outerEnter > outerExit) return vec3(0.0);

              float t0 = outerEnter;
              float t1 = min(outerExit, sceneT);
              if(t1 <= t0) return vec3(0.0);

              float tPick = mix(t0, t1, 0.35 + 0.15 * jitter);
              vec3 pW = roW + rdW * tPick;

              vec3 lp = normalize(pW - uPlanetCenterW);

              float t = uTime * uCloudWindSpeed;

              float cs = cos(t), sn = sin(t);
              vec3 d2 = vec3(lp.x*cs - lp.z*sn, lp.y, lp.x*sn + lp.z*cs);

              vec3 flow1 = vec3(0.37, 0.00, 0.29) * t;
              vec3 flow2 = vec3(-0.21, 0.00, 0.41) * (t * 1.35);

              vec3 q1 = d2 * (uCloudFreq * uCheapCloudScale) + flow1;
              vec3 q2 = d2 * (uCloudDetailFreq * 0.35 * uCheapCloudScale) + flow2 + vec3(17.3,9.1,33.7);

              float n1 = valueNoise(q1);
              float n2 = valueNoise(q2);
              float n  = mix(n1, n2, 0.55);

              float edge = 0.25 / max(uCheapCloudSharp, 1e-3);

              float cov = uCloudCoverage - 0.08 * uCheapCloudFarBoost;

              float m = smoothstep(cov, cov + edge, n);
              m = pow(saturate(m), 1.0 / max(uCheapCloudContrast, 1e-3));

              float h = abs(d2.y);
              float prof = smoothstep(0.10, 0.75, 1.0 - h);

              float a = m * prof * uCheapCloudAlpha * (1.0 + uCheapCloudFarBoost);

              float ndl = saturate(dot(lp, sunDir) * 0.5 + 0.5);
              float nightMask = mix(uMinLight, 1.0, pow(ndl, uNightDarken));

              float mu = dot(rdW, sunDir);
              float phase = phaseHG(mu, clamp(uCloudPhase, -0.5, 0.95));

              float rim = pow(1.0 - saturate(dot(-rdW, lp)), 2.5) * uCheapCloudRim * (1.0 + 0.65 * uCheapCloudFarBoost);

              vec3 col = vec3(1.0) * (0.35 + 0.65 * ndl) * (0.55 + 0.45 * phase);
              col += rim * vec3(1.0);

              col *= nightMask;

              outA = clamp(a, 0.0, 0.70);
              return col;
            }

            void main(){
              vec2 uv = clamp(vUv, 0.0, 1.0);
              vec2 ndc = uv * 2.0 - 1.0;

              vec4 farV4 = uInvProjMatrix * vec4(ndc, 1.0, 1.0);
              vec3 farV = farV4.xyz / farV4.w;
              vec3 rdV = normalize(farV);

              vec3 roW = (uInvViewMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
              vec3 farW = (uInvViewMatrix * vec4(farV, 1.0)).xyz;
              vec3 rdW = normalize(farW - roW);

              float sceneT = sceneDistanceFromLogDepth(uv, rdV);

              vec3 sunDir = normalize(uSunPosW - uPlanetCenterW);
              float jitter = blueJitter();

              float atmoR = uPlanetRadius + uAtmoHeight;
              vec2 tAtmo = raySphere(roW, rdW, uPlanetCenterW, atmoR);
              if(tAtmo.x > tAtmo.y) discard;

              vec2 tGround = raySphere(roW, rdW, uPlanetCenterW, uPlanetRadius);

              float t0 = max(tAtmo.x, 0.0);
              float t1 = tAtmo.y;

              if(tGround.x <= tGround.y && tGround.x > 0.0){
                t1 = min(t1, tGround.x);
              }

              if(t0 > sceneT) discard;
              t1 = min(t1, sceneT);
              if(t1 <= t0) discard;

              float stepsA = max(8.0, uAtmoSteps);
              float dtA = (t1 - t0) / stepsA;
              float scaleH = max(1e-3, uAtmoHeight * uAtmoScaleHeight);

              vec3 atmoCol = vec3(0.0);
              float atmoAlpha = 0.0;
              float optical = 0.0;

              for(float i = 0.0; i < 256.0; i += 1.0){
                if(i >= stepsA) break;

                float t = t0 + (i + 0.5 + jitter) * dtA;
                vec3 p = roW + rdW * t;

                float r = length(p - uPlanetCenterW);
                float h = max(0.0, r - uPlanetRadius);

                vec3 up = (p - uPlanetCenterW) / max(r, 1e-6);
                float day = saturate(dot(up, sunDir) * 0.5 + 0.5);
                float lightMask = mix(uMinLight, 1.0, pow(day, uNightDarken));

                float vis = sunVisibility(p, uSunPosW);
                float localLight = lightMask * mix(1.0, vis, 1.0);

                float dayBoost = mix(1.0, uDayOpacityBoost, smoothstep(0.15, 0.95, day));

                float dens = exp(-h / scaleH) * uAtmoDensity * dayBoost;

                float eclipseDim = mix(1.0, 0.45, 1.0 - vis);
                dens *= eclipseDim;

                float term = abs(day - 0.5) * 2.0;
                float sunsetBand = 1.0 - smoothstep(0.10, 0.62, term);
                sunsetBand *= sunsetBand;

                vec3 blueCol = vec3(0.18, 0.55, 1.25) * uBlueStrength;
                vec3 redCol  = vec3(1.00, 0.30, 0.10) * uSunsetStrength;
                vec3 scatCol = mix(blueCol, redCol, sunsetBand);

                optical += dens * dtA * 0.6;
                float trans = exp(-optical * 0.06);

                float mu = dot(rdW, sunDir);
                float glare = pow(saturate(mu), 32.0) * uSunGlare;
                vec3 glareCol = vec3(0.55, 0.72, 0.98);

                atmoCol += scatCol * dens * dtA * trans * localLight;
                atmoCol += glare   * dens * dtA * glareCol * localLight;

                float aStep = 1.0 - exp(-dens * dtA * 0.06);
                float alphaBoost = mix(0.65, 1.0, smoothstep(0.10, 0.95, day));
                atmoAlpha += (1.0 - atmoAlpha) * aStep * alphaBoost;
              }

              float pathLen = (t1 - t0) / max(uAtmoHeight, 1e-6);
              float edgeSoft = smoothstep(0.0, 1.0, saturate(pathLen * 0.65));
              atmoAlpha *= edgeSoft;
              atmoCol *= edgeSoft;

              atmoAlpha = clamp(atmoAlpha, 0.0, 0.55);

              atmoCol *= mix(vec3(1.0), uAtmoTint, 0.85);

              float cloudBaseR = uPlanetRadius + uCloudBase;
              float cloudTopR  = cloudBaseR + uCloudThickness;

              vec2 tOuter = raySphere(roW, rdW, uPlanetCenterW, cloudTopR);
              vec2 tInner = raySphere(roW, rdW, uPlanetCenterW, cloudBaseR);

              vec3 cloudCol = vec3(0.0);
              float cloudAlpha = 0.0;

              bool hitOuter = (tOuter.x <= tOuter.y);

              if(hitOuter){
                if(uUseCheapClouds > 0.5){
                  cloudCol = cheapClouds(roW, rdW, tOuter, tInner, sceneT, jitter, sunDir, cloudAlpha);
                } else {
                  float groundT = 1e9;
                  if(tGround.x <= tGround.y && tGround.x > 0.0) groundT = tGround.x;

                  float mu = dot(rdW, sunDir);
                  float phase = phaseHG(mu, clamp(uCloudPhase, -0.5, 0.95));

                  bool hitInner = (tInner.x <= tInner.y);
                  float outerEnter = max(tOuter.x, 0.0);
                  float outerExit  = max(tOuter.y, 0.0);

                  if(hitInner){
                    float innerEnter = max(tInner.x, 0.0);
                    float innerExit  = max(tInner.y, 0.0);

                    float a0 = outerEnter;
                    float a1 = min(innerEnter, outerExit);
                    a1 = min(a1, groundT);
                    marchCloudSegment(roW, rdW, a0, a1, sceneT, jitter, sunDir, phase, cloudCol, cloudAlpha);

                    float b0 = innerExit;
                    float b1 = outerExit;
                    b1 = min(b1, groundT);
                    marchCloudSegment(roW, rdW, b0, b1, sceneT, jitter, sunDir, phase, cloudCol, cloudAlpha);

                  } else {
                    float s0 = outerEnter;
                    float s1 = min(outerExit, groundT);
                    marchCloudSegment(roW, rdW, s0, s1, sceneT, jitter, sunDir, phase, cloudCol, cloudAlpha);
                  }
                }
              }

              cloudAlpha = clamp(cloudAlpha, 0.0, 0.60);
              cloudCol *= mix(vec3(1.0), uCloudTint, 0.65);

              vec3 col = atmoCol;
              float a = atmoAlpha;

              col = mix(col, cloudCol, cloudAlpha);
              a = max(a, cloudAlpha);

              gl_FragColor = vec4(col, a);
            }`;

            const cloudMaskFS = atmoFS.replace(
                "gl_FragColor = vec4(col, a);",
                "gl_FragColor = vec4(vec3(cloudAlpha), 1.0);",
            );

            const MAX_OCCLUDERS = 24;
            const occluderCenters = new Float32Array(MAX_OCCLUDERS * 3);
            const occluderRadii = new Float32Array(MAX_OCCLUDERS);

            // Shared eclipse helpers (CPU side) for things that aren’t in the atmo shader
            // (e.g. underwater fog / post tint). Mirrors the GLSL in atmoFS.
            function bodyRadiusForEclipse(b) {
                const sl = b?.seaLevel;
                if (typeof sl === "number" && sl > 0) return sl;
                const br = b?.cfg?.baseRadius ?? b?.baseRadius;
                return typeof br === "number" && isFinite(br) && br > 0
                    ? br
                    : 1400;
            }

            function raySphereHitCPU(ro, rd, c, r) {
                const ocx = ro.x - c.x;
                const ocy = ro.y - c.y;
                const ocz = ro.z - c.z;
                const b = ocx * rd.x + ocy * rd.y + ocz * rd.z;
                const c0 = ocx * ocx + ocy * ocy + ocz * ocz - r * r;
                let h = b * b - c0;
                if (h < 0) return 1e9;
                h = Math.sqrt(h);
                const t0 = -b - h;
                const t1 = -b + h;
                if (t0 > 0) return t0;
                if (t1 > 0) return t1;
                return 1e9;
            }

            function sunVisibilityCPU(
                pW,
                sunPosW,
                ignoreBody,
                tmp,
                softness,
                strength,
            ) {
                const toSun = tmp.vD.copy(sunPosW).sub(pW);
                const maxT = toSun.length();
                if (maxT <= 1e-6) return 1.0;
                const rd = toSun.multiplyScalar(1.0 / maxT);

                let vis = 1.0;
                for (let i = 0; i < bodies.length; i++) {
                    const b = bodies[i];
                    if (!b || b === ignoreBody) continue;
                    const c = b.group.getWorldPosition(tmp.vE.set(0, 0, 0));
                    const r = bodyRadiusForEclipse(b);

                    const tHit = raySphereHitCPU(pW, rd, c, r);
                    if (tHit < maxT) {
                        const ocx = pW.x - c.x;
                        const ocy = pW.y - c.y;
                        const ocz = pW.z - c.z;
                        const bproj = ocx * rd.x + ocy * rd.y + ocz * rd.z;
                        const d2 = Math.max(
                            0,
                            ocx * ocx + ocy * ocy + ocz * ocz - bproj * bproj,
                        );
                        const d = Math.sqrt(d2);
                        const edge = THREE.MathUtils.smoothstep(
                            d,
                            r,
                            r + r * softness,
                        );
                        vis = Math.min(vis, edge);
                    }
                }

                return THREE.MathUtils.lerp(
                    1.0,
                    vis,
                    THREE.MathUtils.clamp(strength, 0.0, 1.0),
                );
            }

            // If some eclipses don't work, probably it went over the cap and got ignored
            function fillOccludersForBody(pass, outCenters, outRadii, tmp) {
                // Allow relevance sorting
                // using uniforms if available.
                const originW = pass?.mat?.uniforms?.uPlanetCenterW?.value;
                const sunPosW = pass?.mat?.uniforms?.uSunPosW?.value;

                // Helper: choose a valid sphere radius (moons have seaLevel as a negative sentinel)
                function bodyRadius(b) {
                    const sl = b?.seaLevel;
                    if (typeof sl === "number" && sl > 0) return sl;
                    const br = b?.cfg?.baseRadius ?? b?.baseRadius;
                    return typeof br === "number" && isFinite(br) && br > 0
                        ? br
                        : 1400;
                }

                // If we can't get origin/sun, just fill sequentially (still with correct radii).
                const canSort =
                    originW &&
                    sunPosW &&
                    typeof originW.x === "number" &&
                    typeof sunPosW.x === "number";

                let rd = null,
                    maxT = 0;
                if (canSort) {
                    rd = tmp.vB.copy(sunPosW).sub(originW);
                    maxT = rd.length();
                    if (maxT > 1e-6) rd.multiplyScalar(1.0 / maxT);
                    else rd = null;
                }

                // Build candidate occluders from `bodies` only.
                const cand = [];
                for (let i = 0; i < bodies.length; i++) {
                    const b = bodies[i];
                    if (!b || b === pass.body) continue;

                    const c = b.group.getWorldPosition(tmp.vA.set(0, 0, 0));
                    const r = bodyRadius(b);

                    let score = i; // stable fallback ordering
                    if (rd) {
                        const dx = c.x - originW.x;
                        const dy = c.y - originW.y;
                        const dz = c.z - originW.z;

                        const along = dx * rd.x + dy * rd.y + dz * rd.z; // projection on sun ray
                        const v2 = dx * dx + dy * dy + dz * dz;
                        const perp2 = Math.max(0, v2 - along * along);
                        const perp = Math.sqrt(perp2);

                        const between = along > 0.0 && along < maxT;

                        // smaller = more relevant
                        score = (between ? 0.0 : 1000.0) + perp / (r + 1e-6);
                    }

                    cand.push({ x: c.x, y: c.y, z: c.z, r, score });
                }

                if (rd) cand.sort((a, b) => a.score - b.score);

                const n = Math.min(MAX_OCCLUDERS, cand.length);
                for (let i = 0; i < n; i++) {
                    const o = cand[i];
                    outCenters[i * 3 + 0] = o.x;
                    outCenters[i * 3 + 1] = o.y;
                    outCenters[i * 3 + 2] = o.z;
                    outRadii[i] = o.r;
                }

                return n;
            }

            function makeAtmoPassForBody(body) {
                const baseR = body.cfg.baseRadius;

                const u = {
                    uInvViewMatrix: { value: new THREE.Matrix4() },
                    uInvProjMatrix: { value: new THREE.Matrix4() },
                    uDepthTex: { value: rt.depthTexture },
                    uLogDepthFC: { value: 1.0 },

                    uPlanetCenterW: { value: new THREE.Vector3() },
                    uPlanetRadius: { value: baseR },
                    uAtmoHeight: { value: baseR * 0.33 },
                    uSunPosW: { value: new THREE.Vector3() },

                    uBlueNoiseTex: { value: blueNoiseTex },
                    uBlueNoiseSize: { value: new THREE.Vector2(256, 256) },

                    uAtmoSteps: { value: QUALITY_ATMO_STEPS },
                    uAtmoDensity: { value: 0.24 },
                    uAtmoScaleHeight: { value: 0.1 },
                    uBlueStrength: { value: 0.4 },
                    uSunsetStrength: { value: 0.45 },
                    uSunGlare: { value: 0.02 },
                    uNightDarken: { value: 3.2 },
                    uMinLight: { value: 0.005 },
                    uDayOpacityBoost: { value: 1.4 },

                    uCloudBase: { value: baseR * 0.05 },
                    uCloudThickness: { value: baseR * 0.04 },
                    uCloudSteps: { value: QUALITY_CLOUD_STEPS },
                    uCloudDensity: { value: 0.65 },
                    uCloudCoverage: { value: 0.54 },
                    uCloudSoftness: { value: 0.18 },
                    uCloudFreq: { value: 4.0 },
                    uCloudDetailFreq: { value: 15.0 },
                    uCloudWindSpeed: { value: 0.025 },
                    uCloudLightSteps: { value: QUALITY_CLOUD_LIGHT_STEPS },
                    uCloudShadowStrength: { value: 0.55 },
                    uCloudPhase: { value: 0.55 },

                    uUseCheapClouds: { value: 0.0 },
                    uCheapCloudAlpha: { value: 0.22 },
                    uCheapCloudScale: { value: 1.0 },
                    uCheapCloudSharp: { value: 1.6 },
                    uCheapCloudRim: { value: 0.35 },
                    uCheapCloudFarBoost: { value: 0.0 },
                    uCheapCloudContrast: { value: 1.0 },

                    uAtmoTint: {
                        value: new THREE.Color(body.cfg.atmoTint ?? 0x6aa8ff),
                    },
                    uCloudTint: {
                        value: new THREE.Color(body.cfg.cloudTint ?? 0xffffff),
                    },

                    uTime: { value: 0.0 },

                    uOccCount: { value: 0 },
                    uOccCenters: { value: occluderCenters },
                    uOccRadii: { value: occluderRadii },
                    uEclipseSoftness: { value: 0.015 },
                    uEclipseStrength: { value: 1.0 },
                };

                const atmoMat = new THREE.ShaderMaterial({
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    blending: THREE.NormalBlending,
                    uniforms: u,
                    vertexShader: atmoVS,
                    fragmentShader: atmoFS,
                });
                const atmoMesh = new THREE.Mesh(fsTri, atmoMat);
                atmoMesh.frustumCulled = false;
                atmoMesh.visible = false;
                atmoScene.add(atmoMesh);

                const maskMat = new THREE.ShaderMaterial({
                    transparent: false,
                    depthTest: false,
                    depthWrite: false,
                    blending: THREE.NoBlending,
                    uniforms: u,
                    vertexShader: atmoVS,
                    fragmentShader: cloudMaskFS,
                });
                const maskMesh = new THREE.Mesh(fsTri, maskMat);
                maskMesh.frustumCulled = false;
                maskMesh.visible = false;
                atmoScene.add(maskMesh);

                return {
                    body,
                    atmoMesh,
                    maskMesh,
                    uniforms: u,
                    _centerW: new THREE.Vector3(),
                };
            }
            let atmoPasses = bodies
                .filter((b) => b.hasAtmo !== false)
                .map(makeAtmoPassForBody);

            function applyQualityToAtmoPasses() {
                for (const p of atmoPasses) {
                    if (!p || !p.uniforms) continue;
                    p.uniforms.uAtmoSteps.value = QUALITY_ATMO_STEPS;
                    p.uniforms.uCloudSteps.value = QUALITY_CLOUD_STEPS;
                    p.uniforms.uCloudLightSteps.value =
                        QUALITY_CLOUD_LIGHT_STEPS;
                }
            }

            function applyQualityPreset(name) {
                const preset =
                    QUALITY_PRESETS[name] || QUALITY_PRESETS.Descktop;
                currentQuality = QUALITY_PRESETS[name] ? name : "Descktop";
                if (qualitySel) qualitySel.value = currentQuality;

                QUALITY_POINT_SHADOW = preset.pointShadow;
                QUALITY_SPOT_SHADOW = preset.spotShadow;
                QUALITY_ATMO_SCALE = preset.atmoScale;
                QUALITY_CLOUD_SCALE = preset.cloudScale;
                QUALITY_GODRAY_SAMPLES = preset.godRaySamples;
                QUALITY_ATMO_STEPS = preset.atmoSteps;
                QUALITY_CLOUD_STEPS = preset.cloudSteps;
                QUALITY_CLOUD_LIGHT_STEPS = preset.cloudLightSteps;

                // Shadow res
                if (sunLight && sunLight.shadow) {
                    sunLight.shadow.mapSize.set(
                        QUALITY_POINT_SHADOW,
                        QUALITY_POINT_SHADOW,
                    );
                    if (sunLight.shadow.map) {
                        sunLight.shadow.map.dispose();
                        sunLight.shadow.map = null;
                    }
                }
                if (
                    sunLight &&
                    sunLight.shadowLight &&
                    sunLight.shadowLight.shadow
                ) {
                    sunLight.shadowLight.shadow.mapSize.set(
                        QUALITY_SPOT_SHADOW,
                        QUALITY_SPOT_SHADOW,
                    );
                    if (sunLight.shadowLight.shadow.map) {
                        sunLight.shadowLight.shadow.map.dispose();
                        sunLight.shadowLight.shadow.map = null;
                    }
                }

                // Atmo/Cloud RT res
                if (atmoRT) atmoRT.dispose();
                atmoRT = makeColorRT(
                    Math.max(1, Math.floor(innerWidth * QUALITY_ATMO_SCALE)),
                    Math.max(1, Math.floor(innerHeight * QUALITY_ATMO_SCALE)),
                );
                if (atmoCopyMat)
                    atmoCopyMat.uniforms.tAtmo.value = atmoRT.texture;

                if (cloudRT) cloudRT.dispose();
                cloudRT = makeColorRT(
                    Math.max(1, Math.floor(innerWidth * QUALITY_CLOUD_SCALE)),
                    Math.max(1, Math.floor(innerHeight * QUALITY_CLOUD_SCALE)),
                );
                cloudRT.texture.colorSpace = THREE.NoColorSpace;
                if (godRayMat)
                    godRayMat.uniforms.tCloud.value = cloudRT.texture;

                // God ray samples
                if (godRayMat)
                    godRayMat.uniforms.uSamples.value = QUALITY_GODRAY_SAMPLES;

                applyQualityToAtmoPasses();
                renderer.shadowMap.needsUpdate = true;
            }

            if (qualitySel) {
                qualitySel.addEventListener("change", () =>
                    applyQualityPreset(qualitySel.value),
                );
            }
            applyQualityPreset(currentQuality);

            ////////////////////////////////////////////////////////////////////////////////
            // Pointer lock + look
            ////////////////////////////////////////////////////////////////////////////////
            let pointerLocked = false;
            renderer.domElement.addEventListener("pointerdown", () => {
                renderer.domElement.focus();
                renderer.domElement.requestPointerLock();
            });
            document.addEventListener("pointerlockchange", () => {
                pointerLocked =
                    document.pointerLockElement === renderer.domElement;
                crosshair.classList.toggle("on", pointerLocked);
                msg.textContent = pointerLocked
                    ? "Pointer locked."
                    : "Click to lock pointer.";
                if (!pointerLocked) {
                    mouseDX = 0;
                    mouseDY = 0;
                }
            });

            let yaw = 0,
                pitch = 0,
                roll = 0;
            let rollVel = 0;
            const ROLL_ACCEL = 4.5;
            const ROLL_DAMP = 3.0;
            const ROLL_MAX = 2.6;

            const flyQuat = new THREE.Quaternion();
            let mouseDX = 0,
                mouseDY = 0;

            document.addEventListener("mousemove", (e) => {
                if (!pointerLocked) return;
                mouseDX += e.movementX;
                mouseDY += e.movementY;
            });

            ////////////////////////////////////////////////////////////////////////////////
            // Input
            ////////////////////////////////////////////////////////////////////////////////
            const keys = new Set();
            addEventListener("keydown", (e) => keys.add(e.code));
            addEventListener("keyup", (e) => keys.delete(e.code));

            ////////////////////////////////////////////////////////////////////////////////
            // Player + helpers
            ////////////////////////////////////////////////////////////////////////////////
            const tmp = {
                qYaw: new THREE.Quaternion(),
                qPitch: new THREE.Quaternion(),
                refAxis: new THREE.Vector3(),
                eastL: new THREE.Vector3(),
                northL: new THREE.Vector3(),
                forwardYawL: new THREE.Vector3(),
                rightYawL: new THREE.Vector3(),
                camForwardL: new THREE.Vector3(),
                camUpL: new THREE.Vector3(),
                forwardMoveL: new THREE.Vector3(),
                rightMoveL: new THREE.Vector3(),
                moveDirL: new THREE.Vector3(),
                axisL: new THREE.Vector3(),
                playerPosL: new THREE.Vector3(),
                playerPosW: new THREE.Vector3(),
                eyePosW: new THREE.Vector3(),
                worldQuat: new THREE.Quaternion(),
                camForwardW: new THREE.Vector3(),
                camUpW: new THREE.Vector3(),
                lookForwardW: new THREE.Vector3(),
                lookRightW: new THREE.Vector3(),
                lookUpW: new THREE.Vector3(),
                vA: new THREE.Vector3(),
                vB: new THREE.Vector3(),
                vC: new THREE.Vector3(),
                vD: new THREE.Vector3(),
                vE: new THREE.Vector3(),
                dq: new THREE.Quaternion(),
                mLook: new THREE.Matrix4(),
                qLook: new THREE.Quaternion(),
                sunPosW: new THREE.Vector3(),
                sunAimW: new THREE.Vector3(),
                sunRight: new THREE.Vector3(),
                sunUp: new THREE.Vector3(),
                sunFwd: new THREE.Vector3(),
            };

            const player = {
                mode: "walk",
                bodyIndex: 0,
                dirLocal: new THREE.Vector3(0, 1, 0),
                height: 1.7,
                radialVel: 0.0,
                radialOffset: 0.0,
                onGround: true,
                worldPos: new THREE.Vector3(0, 0, 0),
                worldVel: new THREE.Vector3(0, 0, 0),
                walkSpeed: 3.8,
                walkSprint: 6.8,
                flyAccel: 28.0,
                flyBoostAccel: 300.0,
                flyDamp: 0.992,
                followIndex: -1,
                noclip: false,
            };

            function nearestBodyInfo(worldPos) {
                let bestI = -1,
                    bestD = Infinity;
                for (let i = 0; i < bodies.length; i++) {
                    const bPos = bodies[i].group.getWorldPosition(
                        tmp.vA.set(0, 0, 0),
                    );
                    const d = worldPos.distanceTo(bPos);
                    if (d < bestD) {
                        bestD = d;
                        bestI = i;
                    }
                }
                return { i: bestI, d: bestD };
            }

            function pushOutOfTerrainWalk(
                body,
                posL,
                dirL,
                clearance = 0.8,
                maxIter = 6,
            ) {
                const sdf = body.sdf;
                for (let i = 0; i < maxIter; i++) {
                    const d = sdf(posL.x, posL.y, posL.z);
                    if (d >= clearance) break;
                    posL.addScaledVector(dirL, clearance - d);
                }
            }

            function flyCollideNearestBody() {
                const near = nearestBodyInfo(player.worldPos);
                if (near.i < 0) return;
                const b = bodies[near.i];

                const centerW = b.group.getWorldPosition(tmp.vA.set(0, 0, 0));
                const toP = tmp.vB.copy(player.worldPos).sub(centerW);
                const dist = toP.length();
                if (dist < 1e-6) return;

                const dirW = toP.multiplyScalar(1 / dist);
                b.group.getWorldQuaternion(tmp.worldQuat);

                const invQ = b._tmpQ.copy(tmp.worldQuat).invert();
                const dirL = tmp.vC
                    .copy(dirW)
                    .applyQuaternion(invQ)
                    .normalize();

                const surfaceR = b.radiusAtDir(dirL.x, dirL.y, dirL.z);
                const playerRadius = player.height * 0.6;
                const margin = 0.15;
                const minDist = surfaceR + playerRadius + margin;

                if (dist < minDist) {
                    player.worldPos.addScaledVector(dirW, minDist - dist);
                    const vn = player.worldVel.dot(dirW);
                    if (vn < 0) player.worldVel.addScaledVector(dirW, -vn);
                }
            }

            function applyFlyFollow(nearIdx) {
                if (nearIdx < 0) {
                    player.followIndex = -1;
                    return;
                }
                const b = bodies[nearIdx];
                const followDist = (b.cfg.baseRadius ?? 1500) * 8.0 + 900.0;
                const releaseDist = followDist * 1.45;
                const dToCenter = player.worldPos.distanceTo(b.currPos);

                if (player.followIndex === -1) {
                    if (dToCenter < followDist) player.followIndex = nearIdx;
                    else return;
                } else {
                    if (player.followIndex !== nearIdx) {
                        if (dToCenter < followDist * 0.65)
                            player.followIndex = nearIdx;
                    }
                    const fb = bodies[player.followIndex];
                    const dRel = player.worldPos.distanceTo(fb.currPos);
                    if (dRel > releaseDist) {
                        player.followIndex = -1;
                        return;
                    }
                }

                const fb = bodies[player.followIndex];
                tmp.dq
                    .copy(fb.currQuat)
                    .multiply(tmp.qYaw.copy(fb.prevQuat).invert());

                tmp.vA.copy(player.worldPos).sub(fb.prevPos);
                tmp.vA.applyQuaternion(tmp.dq);
                player.worldPos.copy(fb.currPos).add(tmp.vA);

                player.worldVel.applyQuaternion(tmp.dq);
            }

            function respawn() {
                player.mode = "walk";
                player.followIndex = -1;
                player.bodyIndex = 0;
                player.dirLocal.set(0, 1, 0);
                player.radialVel = 0;
                player.radialOffset = 0;
                player.onGround = true;
                player.worldVel.set(0, 0, 0);
                yaw = 0;
                pitch = 0;
                msg.textContent = "Respawned. Click to lock pointer.";
                flyQuat.identity();
                roll = 0;
                rollVel = 0;
            }

            // Cheat: noclip toggle (KeyI)
            // - Forces fly mode
            // - Disables planet-follow + collision push-out while enabled
            addEventListener("keydown", (e) => {
                if (e.code !== "KeyI") return;
                player.noclip = !player.noclip;

                if (player.noclip && player.mode !== "fly") {
                    player.mode = "fly";
                    player.followIndex = -1;
                    player.worldVel.set(0, 0, 0);
                    player.worldPos.copy(camera.position);
                    flyQuat.copy(camera.quaternion);
                    roll = 0;
                    rollVel = 0;
                }

                msg.textContent = player.noclip
                    ? "NOCLIP: ON (KeyI to toggle)"
                    : "NOCLIP: OFF (KeyI to toggle)";
            });
            addEventListener("keydown", (e) => {
                if (e.code === "KeyR") respawn();
            });

            addEventListener("keydown", (e) => {
                if (e.code === "KeyF" && player.mode === "walk") {
                    const b = bodies[player.bodyIndex];
                    b.group.updateMatrixWorld(true);

                    const surfaceR = b.radiusAtDir(
                        player.dirLocal.x,
                        player.dirLocal.y,
                        player.dirLocal.z,
                    );
                    const r = surfaceR + player.height + player.radialOffset;
                    tmp.playerPosL.copy(player.dirLocal).multiplyScalar(r);
                    pushOutOfTerrainWalk(
                        b,
                        tmp.playerPosL,
                        player.dirLocal,
                        1.2,
                    );

                    player.worldPos
                        .copy(tmp.playerPosL)
                        .applyMatrix4(b.group.matrixWorld);
                    player.worldVel.set(0, 0, 0);
                    player.mode = "fly";
                    flyQuat.copy(camera.quaternion);
                    roll = 0;
                    rollVel = 0;
                    player.followIndex = -1;
                    msg.textContent = "Takeoff! (Press L to land nearest.)";
                }

                if (e.code === "KeyL" && player.mode === "fly") {
                    const near = nearestBodyInfo(player.worldPos);
                    if (near.i < 0) return;
                    const b = bodies[near.i];

                    const bodyPos = b.group.getWorldPosition(
                        tmp.vA.set(0, 0, 0),
                    );
                    const toPlayer = tmp.vB.copy(player.worldPos).sub(bodyPos);
                    const dist = toPlayer.length();
                    const dirW = toPlayer.normalize();

                    b.group.getWorldQuaternion(tmp.worldQuat);
                    const invQ = tmp.worldQuat.clone().invert();
                    const dirL = tmp.vC
                        .copy(dirW)
                        .applyQuaternion(invQ)
                        .normalize();

                    const surfaceR = b.radiusAtDir(dirL.x, dirL.y, dirL.z);
                    const maxLand = surfaceR + player.height + 120.0;
                    if (dist > maxLand) {
                        msg.textContent = `Too far to land. Get closer to ${b.cfg.name ?? "planet"}.`;
                        return;
                    }

                    player.mode = "walk";
                    roll = 0;
                    rollVel = 0;
                    player.followIndex = -1;
                    player.bodyIndex = near.i;
                    player.dirLocal.copy(dirL);
                    player.radialOffset = Math.max(
                        0,
                        dist - (surfaceR + player.height),
                    );
                    player.radialVel = 0;
                    player.onGround = player.radialOffset <= 0.001;
                    player.worldVel.set(0, 0, 0);
                    msg.textContent = `Landed on ${b.cfg.name ?? "planet"}.`;
                }
            });

            function updateWalk(dt) {
                const b = bodies[player.bodyIndex];
                const upL = tmp.vA.copy(player.dirLocal).normalize();

                if (pointerLocked) {
                    const sens = 0.0022;
                    yaw -= mouseDX * sens;
                    pitch -= mouseDY * sens;
                    pitch = THREE.MathUtils.clamp(pitch, -1.45, 1.45);
                }
                mouseDX = 0;
                mouseDY = 0;

                tmp.refAxis.set(0, 1, 0);
                if (Math.abs(upL.dot(tmp.refAxis)) > 0.92)
                    tmp.refAxis.set(1, 0, 0);

                tmp.eastL.copy(tmp.refAxis).cross(upL).normalize();
                tmp.northL.copy(upL).cross(tmp.eastL).normalize();

                tmp.qYaw.setFromAxisAngle(upL, yaw);
                tmp.forwardYawL
                    .copy(tmp.northL)
                    .applyQuaternion(tmp.qYaw)
                    .normalize();
                tmp.rightYawL
                    .copy(tmp.eastL)
                    .applyQuaternion(tmp.qYaw)
                    .normalize();

                tmp.qPitch.setFromAxisAngle(tmp.rightYawL, pitch);
                tmp.camForwardL
                    .copy(tmp.forwardYawL)
                    .applyQuaternion(tmp.qPitch)
                    .normalize();
                tmp.camUpL
                    .copy(tmp.rightYawL)
                    .cross(tmp.camForwardL)
                    .normalize();

                tmp.forwardMoveL
                    .copy(tmp.camForwardL)
                    .addScaledVector(upL, -tmp.camForwardL.dot(upL));
                if (tmp.forwardMoveL.lengthSq() < 1e-10)
                    tmp.forwardMoveL.copy(tmp.forwardYawL);
                else tmp.forwardMoveL.normalize();

                tmp.rightMoveL.copy(upL).cross(tmp.forwardMoveL).normalize();

                let mx = 0,
                    my = 0;
                if (keys.has("KeyW")) my -= 1;
                if (keys.has("KeyS")) my += 1;
                if (keys.has("KeyA")) mx -= 1;
                if (keys.has("KeyD")) mx += 1;

                const spd =
                    keys.has("ShiftLeft") || keys.has("ShiftRight")
                        ? player.walkSprint
                        : player.walkSpeed;

                tmp.moveDirL
                    .set(0, 0, 0)
                    .addScaledVector(tmp.forwardMoveL, my)
                    .addScaledVector(tmp.rightMoveL, mx);

                if (tmp.moveDirL.lengthSq() > 0) {
                    tmp.moveDirL.normalize();
                    const surfaceR = b.radiusAtDir(upL.x, upL.y, upL.z);
                    const ang = (spd * dt) / Math.max(surfaceR, 1.0);
                    tmp.axisL.copy(tmp.moveDirL).cross(upL).normalize();
                    player.dirLocal
                        .applyQuaternion(
                            tmp.qYaw.setFromAxisAngle(tmp.axisL, ang),
                        )
                        .normalize();
                }

                const g = 11.5;
                if (keys.has("Space") && player.onGround) {
                    player.radialVel = 7.5;
                    player.onGround = false;
                }
                player.radialVel -= g * dt;
                player.radialOffset += player.radialVel * dt;

                if (player.radialOffset < 0) {
                    player.radialOffset = 0;
                    player.radialVel = 0;
                    player.onGround = true;
                }

                const surfaceR = b.radiusAtDir(
                    player.dirLocal.x,
                    player.dirLocal.y,
                    player.dirLocal.z,
                );
                const r = surfaceR + player.height + player.radialOffset;
                tmp.playerPosL.copy(player.dirLocal).multiplyScalar(r);
                pushOutOfTerrainWalk(b, tmp.playerPosL, player.dirLocal, 1.2);

                b.group.updateMatrixWorld(true);
                tmp.playerPosW
                    .copy(tmp.playerPosL)
                    .applyMatrix4(b.group.matrixWorld);

                b.group.getWorldQuaternion(tmp.worldQuat);
                tmp.camForwardW
                    .copy(tmp.camForwardL)
                    .applyQuaternion(tmp.worldQuat)
                    .normalize();
                tmp.camUpW
                    .copy(tmp.camUpL)
                    .applyQuaternion(tmp.worldQuat)
                    .normalize();

                tmp.eyePosW
                    .copy(tmp.playerPosW)
                    .addScaledVector(tmp.camUpW, 0.2);
                camera.position.copy(tmp.eyePosW);
                camera.up.copy(tmp.camUpW);
                camera.lookAt(tmp.vB.copy(tmp.eyePosW).add(tmp.camForwardW));

                player.worldPos.copy(tmp.playerPosW);
            }

            function updateFly(dt) {
                if (!player.noclip) {
                    const near = nearestBodyInfo(player.worldPos);
                    applyFlyFollow(near.i);
                }

                if (pointerLocked) {
                    const sens = 0.0022;
                    const yawDelta = -mouseDX * sens;
                    const pitchDelta = -mouseDY * sens;

                    const fwd = tmp.lookForwardW
                        .set(0, 0, -1)
                        .applyQuaternion(flyQuat)
                        .normalize();
                    const up = tmp.lookUpW
                        .set(0, 1, 0)
                        .applyQuaternion(flyQuat)
                        .normalize();
                    const right = tmp.lookRightW
                        .copy(fwd)
                        .cross(up)
                        .normalize();

                    tmp.qYaw.setFromAxisAngle(up, yawDelta);
                    tmp.qPitch.setFromAxisAngle(right, pitchDelta);

                    flyQuat.premultiply(tmp.qYaw);
                    flyQuat.premultiply(tmp.qPitch);
                    flyQuat.normalize();
                }
                mouseDX = 0;
                mouseDY = 0;

                let rIn = 0;
                if (keys.has("KeyQ")) rIn -= 1;
                if (keys.has("KeyE")) rIn += 1;

                rollVel += rIn * ROLL_ACCEL * dt;
                rollVel = THREE.MathUtils.clamp(rollVel, -ROLL_MAX, ROLL_MAX);
                rollVel *= Math.exp(-ROLL_DAMP * dt);

                if (Math.abs(rollVel) > 1e-5) {
                    const fwd = tmp.lookForwardW
                        .set(0, 0, -1)
                        .applyQuaternion(flyQuat)
                        .normalize();
                    tmp.dq.setFromAxisAngle(fwd, rollVel * dt);
                    flyQuat.premultiply(tmp.dq);
                    flyQuat.normalize();
                }

                const forwardW = tmp.lookForwardW
                    .set(0, 0, -1)
                    .applyQuaternion(flyQuat)
                    .normalize();
                const upW = tmp.lookUpW
                    .set(0, 1, 0)
                    .applyQuaternion(flyQuat)
                    .normalize();
                const rightW = tmp.lookRightW
                    .copy(forwardW)
                    .cross(upW)
                    .normalize();

                let ax = 0,
                    ay = 0,
                    az = 0;
                if (keys.has("KeyW")) az += 1;
                if (keys.has("KeyS")) az -= 1;
                if (keys.has("KeyD")) ax += 1;
                if (keys.has("KeyA")) ax -= 1;
                if (keys.has("Space")) ay += 1;
                if (keys.has("ControlLeft") || keys.has("ControlRight"))
                    ay -= 1;

                const boost = keys.has("ShiftLeft") || keys.has("ShiftRight");
                const accel = boost ? player.flyBoostAccel : player.flyAccel;

                const thrust01 = Math.min(
                    1.0,
                    Math.hypot(ax, ay, az) / 1.7320508075688772,
                );

                tmp.vA
                    .set(0, 0, 0)
                    .addScaledVector(forwardW, az)
                    .addScaledVector(rightW, ax)
                    .addScaledVector(upW, ay);

                if (tmp.vA.lengthSq() > 0) tmp.vA.normalize();

                player.worldVel.addScaledVector(tmp.vA, accel * dt);
                player.worldVel.multiplyScalar(
                    Math.pow(player.flyDamp, dt * 60),
                );
                player.worldPos.addScaledVector(player.worldVel, dt);

                updateFlyEngineSound(dt, thrust01, boost);

                if (!player.noclip) flyCollideNearestBody();

                camera.position.copy(player.worldPos);
                camera.quaternion.copy(flyQuat);
                camera.updateMatrixWorld(true);
            }

            function initialSpawn() {
                const b = bodies[0];
                player.mode = "walk";
                player.followIndex = -1;
                player.bodyIndex = 0;
                player.dirLocal.set(0, 1, 0);

                const surfaceR = b.radiusAtDir(
                    player.dirLocal.x,
                    player.dirLocal.y,
                    player.dirLocal.z,
                );
                const r = surfaceR + player.height;
                tmp.playerPosL.copy(player.dirLocal).multiplyScalar(r);
                pushOutOfTerrainWalk(b, tmp.playerPosL, player.dirLocal, 1.2);

                b.group.updateMatrixWorld(true);
                tmp.playerPosW
                    .copy(tmp.playerPosL)
                    .applyMatrix4(b.group.matrixWorld);

                player.worldPos.copy(tmp.playerPosW);
                player.worldVel.set(0, 0, 0);
                yaw = 0;
                pitch = 0;

                flyQuat.identity();
                roll = 0;
                rollVel = 0;
            }

            // ============================================================================
            // Warp controller (triggered from FULL galaxy map double-click)
            // ============================================================================
            const chargeUI = makeChargeUI(document.getElementById("chargeUI"));
            const chargeSound = makeChargeSound();

            // Reuse the warp-charge synth as a continuous "engine/motor" hum in fly mode.
            // Warp takes ownership while active; otherwise we drive it from flight throttle/speed.
            let flyEngineP = 0.0; // smoothed 0..1

            function updateFlyEngineSound(dt, thrust01, boost) {
                // If warp is active, the warp controller drives this sound.
                if (warpCtrl?.warp?.active) return;

                // Only run in fly mode; otherwise fade out.
                if (player.mode !== "fly") {
                    flyEngineP = 0.0;
                    chargeSound?.stop?.();
                    return;
                }

                const spd = player.worldVel.length();

                // Map speed to 0..1 with a soft knee (works across wide ranges).
                const vScale = boost ? 160.0 : 80.0;
                const speed01 = 1.0 - Math.exp(-spd / vScale);

                // Mix speed + thrust + a little boost punch.
                const desired = Math.min(
                    1.0,
                    Math.max(speed01, thrust01 * 0.55, boost ? 0.35 : 0.0),
                );

                // dt-stable smoothing
                const a = 1.0 - Math.exp(-6.0 * Math.max(0.0, dt));
                flyEngineP += (desired - flyEngineP) * a;

                // Keep it subtle compared to full warp charge (0.10..~0.65)
                chargeSound.ensureAudio?.();
                chargeSound.start?.();
                chargeSound.update?.(0.1 + 0.55 * flyEngineP);
            }

            // Resume audio on first user gesture (required by browsers)
            window.addEventListener(
                "pointerdown",
                async () => {
                    chargeSound.ensureAudio();
                    await chargeSound.resume();
                },
                { once: false },
            );
            const warpOverlay = createWarpOverlay(
                THREE,
                innerWidth,
                innerHeight,
            );
            resizeWarpOverlay(warpOverlay.warpMat, innerWidth, innerHeight);

            function getWarpDirection(target) {
                // direction is derived from the chosen galaxy target
                return tmp.vA
                    .set(target?.x ?? 0, (target?.y ?? 0) * 0.6, -1.25)
                    .normalize();
            }

            const warpCtrl = makeWarpController({
                THREE,
                warpMat: warpOverlay.warpMat,
                chargeUI,
                chargeSound,
                canWarp: () => player?.mode === "fly", // only allow warping in fly mode
                getWarpDirection,
                onWarpStart: (target) => {
                    msg.textContent = `Warping to ${target?.name ?? "unknown"}…`;
                    // release pointer lock so the overlay feels clean
                    if (document.pointerLockElement) document.exitPointerLock();
                    pointerLocked = false;
                    crosshair?.classList.remove("on");
                    mouseDX = 0;
                    mouseDY = 0;
                    // ensure we are in a safe state
                    player.followIndex = -1;
                    player.worldVel.set(0, 0, 0);
                    player.worldPos.copy(camera.position);
                    flyQuat.copy(camera.quaternion);
                    roll = 0;
                    rollVel = 0;
                },
                onWarpRebuildSystem: (target) => {
                    rebuildSystemForWarp(target);
                },
                onWarpArrive: (target) => {
                    msg.textContent = `Arrived at ${target?.name ?? "unknown"} (seed ${target?.seed ?? "?"}).`;
                    mouseDX = 0;
                    mouseDY = 0;
                },

                addVelocityForward: (dirW, accel, dt) =>
                    player.worldVel.addScaledVector(dirW, accel * dt),
                dampVelocity: (damp, dt) =>
                    player.worldVel.multiplyScalar(Math.pow(damp, dt * 60)),

                integratePosition: (dt) => {
                    // Move using the same collision push-out as normal fly mode
                    player.worldPos.addScaledVector(player.worldVel, dt);
                    if (!player.noclip) flyCollideNearestBody();
                    camera.position.copy(player.worldPos);
                    camera.quaternion.copy(flyQuat);
                    camera.updateMatrixWorld(true);
                },

                interpolateLookAt: (p01, dirW, dt) => {
                    // Build a camera quaternion that looks along dirW, then ease toward it.
                    tmp.mLook.lookAt(
                        player.worldPos,
                        tmp.vC.copy(player.worldPos).add(dirW),
                        tmp.vB.set(0, 1, 0),
                    );
                    tmp.qLook.setFromRotationMatrix(tmp.mLook);

                    // dt-stable easing; stronger as the charge completes
                    const base = 1.0 - Math.pow(0.02, dt * 60);
                    const k = THREE.MathUtils.clamp(
                        base * (0.15 + 0.85 * p01),
                        0,
                        1,
                    );
                    flyQuat.slerp(tmp.qLook, k);
                    flyQuat.normalize();
                },
            });

            // Keep overlay resolution correct
            addEventListener("resize", () =>
                resizeWarpOverlay(warpOverlay.warpMat, innerWidth, innerHeight),
            );

            ////////////////////////////////////////////////////////////////////////////////
            // Main loop
            ////////////////////////////////////////////////////////////////////////////////
            const LOD_NEAREST_K = 1;
            let last = performance.now();

            const FPS_CAP = 60;
            const FRAME_MS = 1000 / FPS_CAP;
            let nextFrameTime = performance.now();
            let lastSimTime = performance.now();

            function tick(now) {
                if (now < nextFrameTime) return requestAnimationFrame(tick);

                let dt = (now - lastSimTime) / 1000;
                lastSimTime = now;

                dt = Math.min(dt, 0.033);

                const t = now * 0.001;

                // Warp sequencing
                warpCtrl.update(dt, t);

                sky.position.copy(camera.position);
                sky.material.uniforms.uTime.value = t;

                for (const b of bodies) b.beginFrameCapture();
                for (const b of bodies) b.updateOrbit(dt);

                // Sun position for everything
                sun.getWorldPosition(tmp.sunPosW);
                for (const b of bodies) b.endFrameCapture();

                if (!galaxyOpen && !warpCtrl.isMovementLocked()) {
                    if (player.mode === "walk") updateWalk(dt);
                    else updateFly(dt);
                }

                // If we left fly mode, fade out the engine hum (but never interrupt warp audio).
                if (player.mode !== "fly" && !warpCtrl?.warp?.active) {
                    flyEngineP = 0.0;
                    chargeSound?.stop?.();
                }
                // Update sun SpotLight aiming
                tmp.sunAimW.copy(player?.worldPos ?? camera.position);
                updateSunSuperPointLight(tmp.sunPosW, tmp.sunAimW, dt, tmp);
                updateSuperPointLightMask(splMaskedMaterials, sunLight);

                // ocean shader uniforms
                for (const b of bodies) {
                    const sh = b.ocean?.material?.userData?.shader;
                    if (!sh) continue;
                    sh.uniforms.uTime.value = t;
                    const centerW = b.group.getWorldPosition(
                        tmp.vA.set(0, 0, 0),
                    );
                    sh.uniforms.uPlanetCenterW.value.copy(centerW);
                    sh.uniforms.uSunPosW.value.copy(tmp.sunPosW);

                    // Feed eclipse occluders to oceans (per-body buffers)
                    if (
                        sh.uniforms.uOccCount &&
                        b._oceanOccCenters &&
                        b._oceanOccRadii
                    ) {
                        const nOcc = fillOccludersForBody(
                            { body: b, mat: { uniforms: sh.uniforms } },
                            b._oceanOccCenters,
                            b._oceanOccRadii,
                            tmp,
                        );
                        sh.uniforms.uOccCount.value = nOcc;
                        sh.uniforms.uOccCenters.value = b._oceanOccCenters;
                        sh.uniforms.uOccRadii.value = b._oceanOccRadii;
                    }
                }

                // LOD selection + culling
                const camPos = camera.position;
                const order = bodies
                    .map((b, i) => {
                        const c = b.group.getWorldPosition(tmp.vB.set(0, 0, 0));
                        return { b, i, d: c.distanceTo(camPos) };
                    })
                    .sort((a, b) => a.d - b.d);

                for (let idx = 0; idx < order.length; idx++) {
                    const b = order[idx].b;
                    const d = order[idx].d;

                    if (d > b.activeDist) {
                        b.setTerrainActive(false);
                        continue;
                    }
                    b.setTerrainActive(true);

                    if (idx >= LOD_NEAREST_K || d > b.lodDist) {
                        b.forceRootsOnly();
                        continue;
                    }
                    b.updateLOD(camPos, camera);
                }

                // Underwater detection (uses sunPosW now)
                let underwater = false;
                let depth01 = 0.0;

                tintMat.uniforms.uOpacity.value = 0.0;
                particlesMat.uniforms.uOpacity.value = 0.0;

                const nearCam = nearestBodyInfo(camera.position);

                if (nearCam.i >= 0) {
                    const b = bodies[nearCam.i];
                    const center = b.group.getWorldPosition(
                        tmp.vA.set(0, 0, 0),
                    );
                    const dist = camera.position.distanceTo(center);

                    if (b.ocean && dist < b.seaLevel) {
                        underwater = true;

                        const depth = b.seaLevel - dist;
                        const UNDERWATER_VIS_RANGE = 20.0;
                        depth01 = THREE.MathUtils.clamp(
                            depth / UNDERWATER_VIS_RANGE,
                            0,
                            1,
                        );

                        const upP = tmp.vB
                            .copy(camera.position)
                            .sub(center)
                            .normalize();
                        const sunDir = tmp.vC
                            .copy(tmp.sunPosW)
                            .sub(center)
                            .normalize();
                        const day = THREE.MathUtils.clamp(
                            upP.dot(sunDir) * 0.5 + 0.5,
                            0,
                            1,
                        );

                        const NIGHT_DARKEN = 3.2;
                        const MIN_LIGHT = 0.02;
                        let nightMask = THREE.MathUtils.lerp(
                            MIN_LIGHT,
                            1.0,
                            Math.pow(day, NIGHT_DARKEN),
                        );

                        // Eclipse dim (matches atmosphere behavior)
                        const vis = sunVisibilityCPU(
                            camera.position,
                            tmp.sunPosW,
                            b,
                            tmp,
                            0.015,
                            1.0,
                        );
                        const eclipseDim = THREE.MathUtils.lerp(
                            1.0,
                            0.45,
                            1.0 - vis,
                        );
                        nightMask *= eclipseDim;
                        const dayE = THREE.MathUtils.clamp(
                            day * eclipseDim,
                            0,
                            1,
                        );

                        const oceanCol = b.ocean.material.color;

                        scene.fog.color
                            .copy(oceanCol)
                            .multiplyScalar(0.45 * nightMask);
                        scene.fog.density =
                            (0.05 + depth01 * 0.02) *
                            (0.85 + 0.35 * (1.0 - dayE));

                        tintMat.uniforms.uColor.value
                            .copy(oceanCol)
                            .multiplyScalar(0.35 * nightMask);
                        tintMat.uniforms.uOpacity.value =
                            (0.16 + depth01 * 0.28) *
                            (0.7 + 0.3 * (1.0 - dayE));

                        const pulse = 0.5 + 0.5 * Math.sin(t * 1.4);
                        particlesMat.uniforms.uColor.value
                            .copy(oceanCol)
                            .multiplyScalar(0.28 * nightMask);
                        particlesMat.uniforms.uOpacity.value =
                            (0.05 + depth01 * 0.22) *
                            (0.7 + 0.3 * pulse) *
                            (0.75 + 0.25 * (1.0 - dayE));
                    }
                }

                if (!underwater) {
                    scene.fog.color.set(0x000000);
                    scene.fog.density = 0.000012;
                }

                camera.updateMatrixWorld(true);

                // Sun glow distance scaling
                {
                    const d = camera.position.distanceTo(tmp.sunPosW);

                    const base = SUN_RADIUS * 8.0;
                    const extra = THREE.MathUtils.clamp(
                        d * 0.035,
                        0,
                        SUN_RADIUS * 30.0,
                    );

                    sunGlow.scale.setScalar(base + extra);

                    sunGlow.material.opacity = THREE.MathUtils.clamp(
                        1.15 - d * 0.0000015,
                        0.45,
                        1.15,
                    );
                }

                // =======================
                // 1) Render scene into rt
                // =======================
                renderer.setRenderTarget(rt);
                renderer.setClearColor(0x000000, 1.0);
                renderer.clear(true, true, true);

                // single-pass shadows (sun decides per-light shadow.needsUpdate)
                renderer.shadowMap.needsUpdate = true;
                renderer.render(scene, camera);

                // =======================
                // 2) Copy rt -> screen
                // =======================
                renderer.setRenderTarget(null);
                renderer.setClearColor(0x000000, 1.0);
                renderer.clear(true, true, true);
                renderer.clearDepth();

                copyMat.uniforms.tColor.value = rt.texture;
                renderer.render(copyScene, screenCam);

                // ============================================================
                // Atmosphere/Clouds into atmoRT + cloud mask into cloudRT
                // ============================================================
                const logDepthFC = 2.0 / Math.log2(camera.far + 1.0);

                renderer.setRenderTarget(atmoRT);
                renderer.setClearColor(0x000000, 0.0);
                renderer.clear(true, false, false);

                renderer.setRenderTarget(cloudRT);
                renderer.setClearColor(0x000000, 1.0);
                renderer.clear(true, false, false);

                const sorted = atmoPasses
                    .map((pass) => {
                        pass.body.group.getWorldPosition(pass._centerW);
                        const camD = camera.position.distanceTo(pass._centerW);
                        const cloudTopR =
                            pass.uniforms.uPlanetRadius.value +
                            pass.uniforms.uCloudBase.value +
                            pass.uniforms.uCloudThickness.value;
                        const nearApprox = camD - cloudTopR;
                        return {
                            pass,
                            centerW: pass._centerW,
                            nearApprox,
                            camD,
                        };
                    })
                    .sort((a, b) => b.nearApprox - a.nearApprox);

                let closestPass = null;
                let closestScore = Infinity;
                for (const it of sorted) {
                    const p = it.pass;
                    const baseR = p.uniforms.uPlanetRadius.value;
                    const cloudTopR =
                        baseR +
                        p.uniforms.uCloudBase.value +
                        p.uniforms.uCloudThickness.value;
                    const score = it.camD - cloudTopR;
                    if (score < closestScore) {
                        closestScore = score;
                        closestPass = p;
                    }
                }

                for (const p of atmoPasses) {
                    p.atmoMesh.visible = false;
                    p.maskMesh.visible = false;
                }

                // Render atmo passes back-to-front
                for (const item of sorted) {
                    const pass = item.pass;

                    pass.uniforms.uPlanetCenterW.value.copy(item.centerW);
                    pass.uniforms.uSunPosW.value.copy(tmp.sunPosW);
                    pass.uniforms.uInvViewMatrix.value.copy(camera.matrixWorld);
                    pass.uniforms.uInvProjMatrix.value.copy(
                        camera.projectionMatrixInverse,
                    );

                    const nOcc = fillOccludersForBody(
                        pass,
                        occluderCenters,
                        occluderRadii,
                        tmp,
                    );
                    pass.uniforms.uOccCount.value = nOcc;
                    pass.uniforms.uOccCenters.value = occluderCenters;
                    pass.uniforms.uOccRadii.value = occluderRadii;

                    pass.uniforms.uDepthTex.value = rt.depthTexture;
                    pass.uniforms.uLogDepthFC.value = logDepthFC;
                    pass.uniforms.uTime.value = t;

                    pass.uniforms.uBlueNoiseTex.value = blueNoiseTex;
                    pass.uniforms.uBlueNoiseSize.value.set(
                        blueNoiseTex.image?.width ?? 256,
                        blueNoiseTex.image?.height ?? 256,
                    );

                    pass.uniforms.uUseCheapClouds.value =
                        pass === closestPass ? 0.0 : 1.0;

                    const far = THREE.MathUtils.clamp(
                        (item.nearApprox - 2500.0) / 14000.0,
                        0,
                        1,
                    );
                    pass.uniforms.uCheapCloudFarBoost.value =
                        pass === closestPass ? 0.0 : 0.25 + 1.35 * far;
                    pass.uniforms.uCheapCloudContrast.value =
                        pass === closestPass ? 1.0 : 1.15 + 0.85 * far;

                    renderer.setRenderTarget(atmoRT);
                    pass.atmoMesh.visible = true;
                    renderer.render(atmoScene, screenCam);
                    pass.atmoMesh.visible = false;
                }

                // Cloud mask only for closestPass
                if (closestPass) {
                    renderer.setRenderTarget(cloudRT);
                    closestPass.maskMesh.visible = true;
                    renderer.render(atmoScene, screenCam);
                    closestPass.maskMesh.visible = false;
                }

                // Overlay atmoRT -> screen
                renderer.setRenderTarget(null);
                renderer.clearDepth();
                atmoCopyMat.uniforms.tAtmo.value = atmoRT.texture;
                renderer.render(atmoCopyScene, screenCam);

                // ============================================================
                // God Rays (screen-space)
                // ============================================================
                const sunScreen = tmp.vA.copy(tmp.sunPosW).project(camera);
                godRayMat.uniforms.uSunScreen.value.set(
                    sunScreen.x * 0.5 + 0.5,
                    sunScreen.y * 0.5 + 0.5,
                );
                godRayMat.uniforms.tDepth.value = rt.depthTexture;
                godRayMat.uniforms.tCloud.value = cloudRT.texture;

                const camFwd = tmp.vC
                    .set(0, 0, -1)
                    .applyQuaternion(camera.quaternion)
                    .normalize();
                const toSun = tmp.vB
                    .copy(tmp.sunPosW)
                    .sub(camera.position)
                    .normalize();
                const sunInFront = camFwd.dot(toSun) > 0.0;

                if (sunInFront && sunScreen.z > 0.0 && !underwater) {
                    const sx = sunScreen.x * 0.5 + 0.5;
                    const sy = sunScreen.y * 0.5 + 0.5;

                    const dx = sx - 0.5,
                        dy = sy - 0.5;
                    const centerFade = Math.max(
                        0,
                        1.0 - Math.sqrt(dx * dx + dy * dy) * 1.35,
                    );

                    const facing = THREE.MathUtils.clamp(
                        camFwd.dot(toSun),
                        0,
                        1,
                    );
                    godRayMat.uniforms.uIntensity.value =
                        0.08 * centerFade * centerFade * facing;
                    godRayMat.uniforms.uSunScreen.value.set(sx, sy);
                } else {
                    godRayMat.uniforms.uIntensity.value = 0.0;
                }

                if (godRayMat.uniforms.uIntensity.value > 0.0) {
                    renderer.clearDepth();
                    renderer.render(godRayScene, screenCam);
                }

                // ============================================================
                // Underwater POST overlays LAST
                // ============================================================
                if (
                    tintMat.uniforms.uOpacity.value > 0.0 ||
                    particlesMat.uniforms.uOpacity.value > 0.0
                ) {
                    particlesMat.uniforms.uTime.value = t;
                    particlesMat.uniforms.uNoiseTex.value = blueNoiseTex;
                    particlesMat.uniforms.uNoiseSize.value.set(
                        blueNoiseTex.image?.width ?? 256,
                        blueNoiseTex.image?.height ?? 256,
                    );
                    renderer.clearDepth();
                    renderer.render(postScene, screenCam);
                }

                // Warp overlay on top of everything
                renderWarpOverlay(
                    renderer,
                    warpOverlay,
                    warpCtrl.isOverlayVisible(),
                );

                // HUD
                const near = nearestBodyInfo(player.worldPos);
                const followName =
                    player.followIndex >= 0
                        ? (bodies[player.followIndex]?.cfg?.name ?? "??")
                        : "none";
                const activeCount = bodies.reduce(
                    (s, b) => s + (b.terrainActive ? 1 : 0),
                    0,
                );

                msg.textContent =
                    (player.mode === "walk"
                        ? `WALK — on ${bodies[player.bodyIndex]?.cfg?.name ?? "planet"} | F takeoff\n`
                        : `FLY — nearest: ${bodies[near.i]?.cfg?.name ?? "none"} | follow: ${followName} | L land\n`) +
                    `Planets: ${bodies.length} | Moons: ${moons.length} | Patch-active: ${activeCount} | Deep LOD planets: ${Math.min(
                        LOD_NEAREST_K,
                        activeCount,
                    )}\n` +
                    `SunLight: SuperPointLight (spot tracks player) | God Rays: ${godRayMat.uniforms.uIntensity.value > 0 ? "on" : "off"} | Blue-noise: ${
                        blueNoiseReady ? "yes" : "loading..."
                    }\n` +
                    (underwater
                        ? `UNDERWATER — murk: ${(depth01 * 100).toFixed(0)}%`
                        : ``);

                drawGalaxyMap();
                drawGalaxyFull();

                // FPS counter (updates 4x/sec)
                fpsFrames++;
                fpsAccum += dt;
                if (now - fpsLast >= 250) {
                    const fps = fpsFrames / Math.max(fpsAccum, 1e-6);
                    fpsEl.textContent = `FPS: ${fps.toFixed(0)}`;
                    fpsFrames = 0;
                    fpsAccum = 0;
                    fpsLast = now;
                }

                nextFrameTime += FRAME_MS;
                if (now - nextFrameTime > 250) nextFrameTime = now;
                requestAnimationFrame(tick);
            }

            addEventListener("resize", () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);

                rt.dispose();
                rt = makeRT(innerWidth, innerHeight);
                copyMat.uniforms.tColor.value = rt.texture;

                atmoRT.dispose();
                atmoRT = makeColorRT(
                    Math.max(1, Math.floor(innerWidth * QUALITY_ATMO_SCALE)),
                    Math.max(1, Math.floor(innerHeight * QUALITY_ATMO_SCALE)),
                );
                atmoCopyMat.uniforms.tAtmo.value = atmoRT.texture;

                cloudRT.dispose();
                cloudRT = makeColorRT(
                    Math.max(1, Math.floor(innerWidth * QUALITY_CLOUD_SCALE)),
                    Math.max(1, Math.floor(innerHeight * QUALITY_CLOUD_SCALE)),
                );
                cloudRT.texture.colorSpace = THREE.NoColorSpace;

                for (const pass of atmoPasses)
                    pass.uniforms.uDepthTex.value = rt.depthTexture;
                godRayMat.uniforms.tDepth.value = rt.depthTexture;
                godRayMat.uniforms.tCloud.value = cloudRT.texture;
            });

            initialSpawn();
            respawn();
            requestAnimationFrame(tick);
        </script>
    </body>
</html>
